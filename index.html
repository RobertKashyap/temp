<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>exp</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#writing-a-simple-operating-system-—">Writing a Simple Operating System —</a></li>
<li><a href="#from-scratch">from Scratch</a>
<ul>
<li><a href="#by">by</a></li>
<li><a href="#nick-blundell">Nick Blundell</a></li>
<li><a href="#school-of-computer-science-university-of-birmingham">School of Computer Science, University of Birmingham,</a></li>
<li><a href="#uk">UK</a></li>
<li><a href="#contents">Contents</a></li>
</ul>
</li>
<li><a href="#chapter-1">Chapter 1</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#chapter-2">Chapter 2</a></li>
<li><a href="#computer-architecture-and-the">Computer Architecture and the</a></li>
<li><a href="#boot-process">Boot Process</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#chapter-3">Chapter 3</a></li>
<li><a href="#boot-sector-programming-in">Boot Sector Programming (in</a></li>
<li><a href="#bit-real-mode">16-bit Real Mode)</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#chapter-4">Chapter 4</a></li>
<li><a href="#entering-32-bit-protected-mode">Entering 32-bit Protected Mode</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#chapter-5">Chapter 5</a></li>
<li><a href="#writing-building-and-loading">Writing, Building, and Loading</a></li>
<li><a href="#your-kernel">Your Kernel</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#chapter-6">Chapter 6</a></li>
<li><a href="#developing-essential-device">Developing Essential Device</a></li>
<li><a href="#drivers-and-a-filesystem">Drivers and a Filesystem</a>
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
<li><a href="#hardware-inputoutput">6.1 Hardware Input/Output</a></li>
<li><a href="#screen-driver">6.2 Screen Driver</a></li>
<li><a href="#handling-interrupts">6.3 Handling Interrupts</a></li>
<li><a href="#keyboard-driver">6.4 Keyboard Driver</a></li>
<li><a href="#hard-disk-driver">6.5 Hard-disk Driver</a></li>
<li><a href="#file-system">6.6 File System</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter-7">Chapter 7</a></li>
<li><a href="#implementing-processes">Implementing Processes</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#chapter-8">Chapter 8</a></li>
<li><a href="#summary-1">Summary</a></li>
<li><a href="#bibliography">Bibliography</a></li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="writing-a-simple-operating-system-—">Writing a Simple Operating System —</h1>
<h1 id="from-scratch">from Scratch</h1>
<h2 id="by">by</h2>
<h2 id="nick-blundell">Nick Blundell</h2>
<h2 id="school-of-computer-science-university-of-birmingham">School of Computer Science, University of Birmingham,</h2>
<h2 id="uk">UK</h2>
<p>Draft: December 2, 2010</p>
<p>Copyright©c 2009–2010 Nick Blundell</p>
<h2 id="contents">Contents</h2>
<ul>
<li>1 Introduction Contents ii</li>
<li>2 Computer Architecture and the Boot Process
<ul>
<li>2.1 The Boot Process</li>
<li>2.2 BIOS, Boot Blocks, and the Magic Number</li>
<li>2.3 CPU Emulation
<ul>
<li>2.3.1 Bochs: A x86 CPU Emulator</li>
<li>2.3.2 QEmu</li>
</ul>
</li>
<li>2.4 The Usefulness of Hexadecimal Notation</li>
</ul>
</li>
<li>3 Boot Sector Programming (in 16-bit Real Mode)
<ul>
<li>3.1 Boot Sector Re-visited</li>
<li>3.2 16-bit Real Mode</li>
<li>3.3 Erm, Hello?
<ul>
<li>3.3.1 Interrupts</li>
<li>3.3.2 CPU Registers</li>
<li>3.3.3 Putting it all Together</li>
</ul>
</li>
<li>3.4 Hello, World!
<ul>
<li>3.4.1 Memory, Addresses, and Labels</li>
<li>3.4.2 ’X’ Marks the Spot
<ul>
<li>Question</li>
</ul>
</li>
<li>3.4.3 Defining Strings</li>
<li>3.4.4 Using the Stack
<ul>
<li>Question</li>
</ul>
</li>
<li>3.4.5 Control Structures
<ul>
<li>Question</li>
</ul>
</li>
<li>3.4.6 Calling Functions</li>
<li>3.4.7 Include Files</li>
<li>3.4.8 Putting it all Together
<ul>
<li>Question</li>
</ul>
</li>
<li>3.4.9 Summary</li>
</ul>
</li>
<li>3.5 Nurse, Fetch me my Steth-o-scope CONTENTS iii
<ul>
<li>3.5.1 Question 5 (Advanced)</li>
</ul>
</li>
<li>3.6 Reading the Disk
<ul>
<li>3.6.1 Extended Memory Access Using Segments</li>
<li>3.6.2 How Disk Drives Work</li>
<li>3.6.3 Using BIOS to Read the Disk</li>
<li>3.6.4 Putting it all Together</li>
</ul>
</li>
</ul>
</li>
<li>4 Entering 32-bit Protected Mode
<ul>
<li>4.1 Adapting to Life Without BIOS</li>
<li>4.2 Understanding the Global Descriptor Table</li>
<li>4.3 Defining the GDT in Assembly</li>
<li>4.4 Making the Switch</li>
<li>4.5 Putting it all Together</li>
</ul>
</li>
<li>5 Writing, Building, and Loading Your Kernel
<ul>
<li>5.1 Understanding C Compilation
<ul>
<li>5.1.1 Generating Raw Machine Code</li>
<li>5.1.2 Local Variables</li>
<li>5.1.3 Calling Functions</li>
<li>5.1.4 Pointers, Addresses, and Data</li>
</ul>
</li>
<li>5.2 Executing our Kernel Code
<ul>
<li>5.2.1 Writing our Kernel</li>
<li>5.2.2 Creating a Boot Sector to Bootstrap our Kernel</li>
<li>5.2.3 Finding Our Way into the Kernel</li>
</ul>
</li>
<li>5.3 Automating Builds with Make
<ul>
<li>5.3.1 Organising Our Operating System’s Code Base</li>
</ul>
</li>
<li>5.4 C Primer
<ul>
<li>5.4.1 The Pre-processor and Directives</li>
<li>5.4.2 Function Declarations and Header Files</li>
</ul>
</li>
</ul>
</li>
<li>6 Developing Essential Device Drivers and a Filesystem
<ul>
<li>6.1 Hardware Input/Output
<ul>
<li>6.1.1 I/O Buses</li>
<li>6.1.2 I/O Programming</li>
<li>6.1.3 Direct Memory Access</li>
</ul>
</li>
<li>6.2 Screen Driver
<ul>
<li>6.2.1 Understanding the Display Device</li>
<li>6.2.2 Basic Screen Driver Implementation</li>
<li>6.2.3 Scrolling the Screen</li>
</ul>
</li>
<li>6.3 Handling Interrupts</li>
<li>6.4 Keyboard Driver</li>
<li>6.5 Hard-disk Driver</li>
<li>6.6 File System</li>
</ul>
</li>
<li>7 Implementing Processes
<ul>
<li>7.1 Single Processing</li>
<li>7.2 Multi-processing</li>
</ul>
</li>
</ul>
<p>CONTENTS iv</p>
<p>8 Summary 72</p>
<p>Bibliography 73</p>
<h1 id="chapter-1">Chapter 1</h1>
<h1 id="introduction">Introduction</h1>
<p>We’ve all used an operating system (OS) before (e.g. Windows XP, Linux, etc.), and<br>
perhaps we have even written some programs to run on one; but what is an OS actually<br>
there for? how much of what I see when I use a computer is done by hardware and how<br>
much is done by software? and how does the computer actually work?<br>
The late Prof. Doug Shepherd, a lively teacher of mine at Lancaster University,<br>
once reminded me amid my grumbling about some annoying programming problem that,<br>
back in the day, before he could evenbeginto attempt any research, he had to write<br>
his own operating system, from scratch. So it seems that, today, we take a lot for<br>
granted about how these wonderful machines actually work underneith all those layers<br>
of software that commonly come bundled with them and which are required for their<br>
day-to-day usefulness.<br>
Here, concentrating on the widely used x86 architecture CPU, we will strip bare our<br>
computer ofallsoftware and follow in Doug’s early footsteps, learning along the way<br>
about:</p>
<ul>
<li>How a computer boots</li>
<li>How to write low-level programs in the barren landscape where no operating<br>
system yet exists</li>
<li>How to configure the CPU so that we can begin to use its extended functionality</li>
<li>How to bootstrap code written in a higher-level language, so that we can really<br>
start to make some progress towards our own operating system</li>
<li>How to create some fundamental operating system services, such as device drivers,<br>
file systems, multi-tasking processing.<br>
Note that, in terms of practical operating system functionality, this guide does not<br>
aim to be extensive, but instead aims to pool together snippets of information from<br>
many sources into a self-contained and coherent document, that will give you a hands-on<br>
experience of low-level programming, how operating systems are written, and the kind<br>
of problems they must solve. The approach taken by this guide is unique in that the<br>
particular languages and tools (e.g. assembly, C, Make, etc.) are not the focus but<br>
instead are treated as a means to an end: we will learn what we need to about these<br>
things to help us achieve our main goal.</li>
</ul>
<p>1</p>
<p>CHAPTER 1. INTRODUCTION 2</p>
<p>This work is not intended as a replacement but rather as a stepping stone to excellent<br>
work such as the Minix project [?] and to operating system development in general.</p>
<h1 id="chapter-2">Chapter 2</h1>
<h1 id="computer-architecture-and-the">Computer Architecture and the</h1>
<h1 id="boot-process">Boot Process</h1>
<h3 id="the-boot-process">2.1 The Boot Process</h3>
<p>Now, we begin our journey.<br>
When we reboot our computer, it must start up again, initially without any notion of<br>
an operating system. Somehow, it must load the operating system — whatever variant<br>
that may be — from some permanent storage device that is currently attached to the<br>
computer (e.g. a floppy disk, a hard disk, a USB dongle, etc.).<br>
As we will shortly discover, the pre-OS environment of your computer offers little in<br>
the way of rich services: at this stage even a simple file system would be a luxury (e.g.<br>
read and write logical files to a disk), but we have none of that. Luckily, what we do have<br>
is the Basic Input/Output Software (BIOS), a collection of software routines that are<br>
initially loaded from a chip into memory and initialised when the computer is switched<br>
on. BIOS provides auto-detection and basic control of your computer’s essential devices,<br>
such as the screen, keyboard, and hard disks.<br>
After BIOS completes some low-level tests of the hardware, particularly whether or<br>
not the installed memory is working correctly, it must boot the operating system stored<br>
on one of your devices. Here, we are reminded, though, that BIOS cannot simply load a<br>
file that represents your operating system from a disk, since BIOS has no notion of a file-<br>
system. BIOS must read specific sectors of data (usually 512 bytes in size) from specific<br>
physical locations of the disk devices, such as Cylinder 2, Head 3, Sector 5 (details of<br>
disk addressing are described later, in Section XXX).<br>
So, the easiest place for BIOS to find our OS is in the first sector of one of the disks<br>
(i.e. Cylinder 0, Head 0, Sector 0), known as theboot sector. Since some of our disks may<br>
not contain an operating systems (they may simply be connected for additional storage),<br>
then it is important that BIOS can determine whether the boot sector of a particular<br>
disk is boot code that is intended for execution or simply data. Note that the CPU does<br>
not differentiate between code and data: both can be interpreted as CPU instructions,<br>
where code is simply instructions that have been crafted by a programmer into some<br>
useful algorithm.</p>
<p>3</p>
<p>CHAPTER 2. COMPUTER ARCHITECTURE AND THE BOOT</p>
<p>PROCESS 4</p>
<p>Again, an unsophisticated means is adopted here by BIOS, whereby the last two<br>
bytes of an intended boot sector must be set to the magic number0xaa55. So, BIOS<br>
loops through each storage device (e.g. floppy drive, hard disk, CD drive, etc.), reads<br>
the boot sector into memory, and instructs the CPU to begin executing the first boot<br>
sector it finds that ends with the magic number.<br>
This is where we seize control of the computer.</p>
<h3 id="bios-boot-blocks-and-the-magic-number">2.2 BIOS, Boot Blocks, and the Magic Number</h3>
<p>If we use a binary editor, such as TextPad [?] or GHex [?], that will let us write raw byte<br>
values to a file — rather than a standard text editor that will convert characters such as<br>
’A’ into ASCII values — then we can craft ourselves a simple yet valid boot sector.</p>
<pre><code>e9 fd ff 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa
</code></pre>
<p>Figure 2.1: A machine code boot sector, with each byte displayed in</p>
<p>hexadecimal.</p>
<pre><code>Note that, in Figure 2.1, the three important features are:
</code></pre>
<ul>
<li>The initial three bytes, in hexadecimal as0xe9,0xfdand0xff, are actually<br>
machine code instructions, as defined by the CPU manufacturer, to perform an<br>
endless jump.</li>
<li>The last two bytes,0x55and0xaa, make up the magic number, which tells BIOS<br>
that this is indeed a boot block and not just data that happens to be on a drive’s<br>
boot sector.</li>
<li>The file is padded with zeros (’*’ indicates zeros omitted for brevity), basically to<br>
position the magic BIOS number at the end of the 512 byte disk sector.<br>
An important note on endianness. You might be wondering why the magic BIOS<br>
number was earlier described as the 16-bit value0xaa55but in our boot sector was<br>
written as the consecutive bytes0x55and0xaa. This is because the x86 architecture<br>
handles multi-byte values inlittle-endianformat, whereby less significant bytes proceed<br>
more significant bytes, which is contrary to our familiar numbering system — though if<br>
our system ever switched and I had£0000005 in my bank account, I would be able to<br>
retire now, and perhaps donate a couple of quid to the needy Ex-millionaires Foundation.<br>
Compilers and assemblers can hide many issues of endianness from us by allowing<br>
us to define the types of data, such that, say, a 16-bit value is serialised automatically<br>
into machine code with its bytes in the correct order. However, it is sometimes useful,</li>
</ul>
<p>CHAPTER 2. COMPUTER ARCHITECTURE AND THE BOOT</p>
<p>PROCESS 5</p>
<p>especially when looking for bugs, to know exactly where an individual byte will be stored<br>
on a storage device or in memory, so endianness is very important.<br>
This is possibly the smallest program your computer could run, but it is a valid<br>
program nonetheless, and we can test this in two ways, the second of which is much safer<br>
and better suited to our kind of experiments:</p>
<ul>
<li>Using whatever means your current operating system will allow, write this boot<br>
block to the first sector of a non-essential storage device (e.g. floppy disk or flash<br>
drive), then reboot the computer.</li>
<li>Use virtual machine software, such as VMWare or VirtualBox, and set the boot<br>
block code as a disk image of a virtual machine, then start-up the virtual machine.<br>
You can be sure this code has been loaded and executed if your computer simply<br>
hangs after booting, without a message such as “No operating system found”. This is the<br>
infinite loop at work, that we put at the start of the code. Without this loop the CPU<br>
would tear off, executing every subsequent instruction in memory, most of which will<br>
be random, uninitialised bytes, until it throws itself into some invalid state and either<br>
reboots or, by chance, stumbles upon and runs a BIOS routine that formats your main<br>
disk.<br>
Remember, it is us that program the computer, and the computer follows our in-<br>
structions blindly, fetching and executing them, until it is switched off; so we need to<br>
make sure that it executes our crafted code rather than random bytes of data held some-<br>
where in memory. At this low level, we have a lot of power and responsibility over our<br>
computer, so we need to learn how to control it.</li>
</ul>
<h3 id="cpu-emulation">2.3 CPU Emulation</h3>
<p>There is athird, more convenient option for testing these low-level programs without<br>
continuously having to reboot a machine or risk scrubbing your important data off a<br>
disk, and that is to use a CPU emulator such as Bochs or QEmu. Unlike machine<br>
virtualisation (e.g. VMware, VirtualBox), which tries to optimise for performance and<br>
therefore usage of the hosted operating system by running guest instructions directly on<br>
the CPU, emulation involves a program that behaves like a specific CPU architecture,<br>
using variables to represent CPU registers and high-level control structures to simulate<br>
lower level jumps and so on, so is much slower but often better suited for development<br>
and debugging such systems.<br>
Note that, in order to do anything useful with an emulator, you need to give it some<br>
code to run in the form of a disk image file. An image file simply is the raw data (i.e.<br>
machine code and data) that would otherwise have been written to medium of a hard<br>
disk, a floppy disk, a CDROM, USB stick, etc. Indeed, some emulators will successfully<br>
boot and run a real operating system from an image file downloaded or extracted from<br>
an installation CDROM — though virtualisation is better suited to this kind of use.<br>
The emulators translate low-level display device instructions into pixel rendering on<br>
a desktop window, so you can see exactly what would be rendered on a real monitor.<br>
In general, and for the exercises in this document, it follows that any machine code<br>
that runs correctly under an emulator will run correctly on the real architecture —<br>
though obviously must faster.</p>
<p>CHAPTER 2. COMPUTER ARCHITECTURE AND THE BOOT</p>
<p>PROCESS 6</p>
<h4 id="bochs-a-x86-cpu-emulator">2.3.1 Bochs: A x86 CPU Emulator</h4>
<p>Bochs requires that we set up a simple configuration file,bochsrc, in the local directory,<br>
that describes details of how real devices (e.g. the screen and keyboard) are to be<br>
emulated and, importantly, which floppy disk image is to be booted when the emulated<br>
computer starts.<br>
Figure 2.2 shows a sample Bochs configuration file that we can use to test the boot<br>
sector written in Section XXX and saved as the filebootsect.bin</p>
<pre><code># Tell bochs to use our boot sector code as though it were
# a floppy disk inserted into a computer at boot time.
floppya: 1_44=boot_sect.bin , status=inserted
boot: a
</code></pre>
<p>Figure 2.2: A simple Bochs configuration file.</p>
<p>To test our boot sector in Bochs, simply type:<br>
$bochs<br>
As a simple experiment, try changing the BIOS magic number in our boot sector to<br>
something invalid then re-running Bochs.<br>
Since Bochs’ emulation of a CPU is close to the real thing, after you’ve tested code<br>
in Bochs, you should be able to boot it on a real machine, on which it will run much<br>
faster.</p>
<h4 id="qemu">2.3.2 QEmu</h4>
<p>QEmu is similar to Bochs, though is much more efficient and capable also of emulating<br>
architectures other than x86. Though QEmu is less well documented than Bochs, a need<br>
for no configuration file means it is easier to get running, as follows:</p>
<pre><code>$qemu &lt;your-os-boot-disk-image-file&gt;
</code></pre>
<h3 id="the-usefulness-of-hexadecimal-notation">2.4 The Usefulness of Hexadecimal Notation</h3>
<p>We’ve already seen some examples ofhexadecimal, so it is important to understand why<br>
hexadecimal is often used in lower-level programming.<br>
First it may be helpful to consider why counting in ten seems so natural to us,<br>
because when we see hexadecimal for the first time we always ask ourselves: why not<br>
simply count to ten? Not being an expert on the matter, I will make the assumption that<br>
counting to ten has something to do with most people having a total of ten fingers on<br>
their hands, which led to the ideas of numbers being represented as 10 distinct symbols:<br>
0,1,2,…8,</p>
<p>CHAPTER 2. COMPUTER ARCHITECTURE AND THE BOOT</p>
<p>PROCESS 7</p>
<p>Decimal has a base of ten (i.e. has ten distinct digit symbols), but hexadecimal has<br>
a base of 16, so we have to invent some new number symbols; and the lazy way is just to<br>
use a few letters, giving us:0,1,2,…8,9,a,b,c,d,e,f, where the single digitd, for<br>
example, represents a count of 13.<br>
To distinguish among hexadecimal and other number systems, we often use the prefix<br>
0x, or sometimes the suffixh, which is especially important for hexadecimal digits that<br>
happen not to contain any of the letter digits, for example:0x50does not equal (decimal)<br>
50 —0x50is actually 80 in decimal.<br>
The thing is, that a computer represent a number as a sequence ofbits(binary digits),<br>
since fundamentally its circuitry can distinguish between only two electrical states: 0 and<br>
1 — it’s like the computer has a total of only two fingers. So, to represent a number<br>
larger than 1 , the computer can bunch together a series of bits, just like we may count<br>
higher than 9 by having two or more digits (e.g. 456 , 23 , etc.).<br>
Names have been adopted for bit series of certain lengths to make it easier to talk<br>
about and agree upon the size of numbers we are dealing with. The instructions of<br>
most computers deal with a minimum of 8 bit values, which are namedbytes. Other<br>
groupings areshort,int, andlong, which usually represent 16-bit, 32-bit, and 64-bit<br>
values, respectively. We also see the termword, that is used to describe the size of the<br>
maximum processing unit of the current mode of the CPU: so in 16-bit real mode, a<br>
wordrefers to a 16-bit value; in 32-bit protected mode, awordrefers to a 32-bit value;<br>
and so on.<br>
So, returning to the benefit of hexadecimal: strings of bits are rather long-winded to<br>
write out but are much easier to convert to and from the more shorthand hexadecimal<br>
notation than to and from our natural decimal system, essentially because we can break<br>
the conversion down into smaller, 4-bit segments of the binary number, rather than try<br>
to add up all of the component bits into a grand total, which gets much harder for larger<br>
bit strings (e.g. 16, 32, 64, etc.). This difficulty with decimal conversion is shown clearly<br>
by the example given in Figure 2.3.</p>
<p>Figure 2.3: Conversion of 1101111010110110 to decimal and hexadecimal</p>
<h1 id="chapter-3">Chapter 3</h1>
<h1 id="boot-sector-programming-in">Boot Sector Programming (in</h1>
<h1 id="bit-real-mode">16-bit Real Mode)</h1>
<p>Even with the example code provided, you will no doubt have found it frustrating writing<br>
machine code in a binary editor. You’d have to remember, or continuously reference,<br>
which of many possible machine codes cause the CPU to do certain functions. Luckily,<br>
you are not alone, and soassemblers have been written that translate more human<br>
friendly instructions into machine code for a particular CPU.<br>
In this chapter we will explore some increasingly sophisticated boot sector programs<br>
to familiarise ourselves with assembly and the barren, pre-OS environment in which our<br>
programs will run.</p>
<h3 id="boot-sector-re-visited">3.1 Boot Sector Re-visited</h3>
<p>Now, we will re-create the binary-edited boot sector from Section XXX instead using<br>
assembly language, so that we can really appreciate the value even of a very low-level<br>
language.<br>
We can assemble this into actual machine code (a sequence of bytes that our CPU<br>
can interpret as instructions) as follows:</p>
<p>$nasm bootsect.asm -f bin -o bootsect.bin<br>
Wherebootsect.asmis the file into which we saved the source code in Figure 3.<br>
andbootsect.binis the assembled machine code that we can install as a boot sector<br>
on a disk.<br>
Note that we used the-f binoption to instruct nasm to producerawmachine code,<br>
rather than a code package that has additional meta information for linking in other rou-<br>
tines that we would expect to use when programming in a more typical operating system<br>
environment. We need none of that cruft. Apart from the low-level BIOS routines, we<br>
are the only software running on this computer now. We are the operating system now,<br>
albeit at this stage with nothing more to offer than an endless loop — but we will soon<br>
build up from this.</p>
<p>8</p>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 9</p>
<pre><code>;
; A simple boot sector program that loops forever.
;
</code></pre>
<pre><code>loop: ; Define a label , "loop", that will allow
; us to jump back to it , forever.
</code></pre>
<pre><code>jmp loop ; Use a simple CPU instruction that jumps
; to a new memory address to continue execution.
; In our case , jump to the address of the current
; instruction.
</code></pre>
<pre><code>times 510-($-$$) db 0 ; When compiled , our program must fit into 512 bytes ,
; with the last two bytes being the magic number ,
; so here , tell our assembly compiler to pad out our
; program with enough zero bytes (db 0) to bring us to the
; 510th byte.
</code></pre>
<pre><code>dw 0xaa55 ; Last two bytes (one word) form the magic number ,
; so BIOS knows we are a boot sector.
</code></pre>
<p>Figure 3.1: A simple boot sector written in assembly language.</p>
<p>Rather than saving this to the boot sector of a floppy disk and rebooting our machine,<br>
we can conveniently test this program by running Bochs:</p>
<p>$bochs<br>
Or, depending on our preference and on availability of an emulator, we could use<br>
QEmu, as follows:</p>
<p>$qemu bootsect.bin<br>
Alternatively, you could load the image file into virtualisation software or write it<br>
onto some bootable medium and boot it from a real computer. Note that, when you<br>
write an image file to some bootable medium, that does not mean you add the file to the<br>
medium’s file system: you must use an appropriate tool to write directly to the medium<br>
in a low-level sense (e.g. directly to the sectors of a disk).<br>
If we’d like to see more easily exactly what bytes the assembler created, we can run<br>
the following command, which displays the binary contents of the file in an easy-to-read<br>
hexadecimal format:</p>
<p>$od -t x1 -A n bootsect.bin<br>
The output of this command should look familiar.<br>
Congratulations, you just wrote a boot sector in assembly language. As we will see,<br>
all operating systems must start this way and then pull themselves up into higher level<br>
abstractions (e.g. higher level languages, such as C/C++)</p>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 10</p>
<h3 id="bit-real-mode-1">3.2 16-bit Real Mode</h3>
<p>CPU manufacturers must go to great lengths to keep their CPUs (i.e. their specific<br>
instruction set) compatible with earlier CPUs, so that older software, and in particular<br>
older operating systems, can still run on the most modern CPUs.<br>
The solution implemented by Intel and compatible CPUs is toemulatethe oldest<br>
CPU in the family: the Intel 8086 , which had support for 16-bit instructions and no<br>
notion ofmemory protection: memory protection is crucial for the stabilty of modern<br>
operating systems, since it allows an operating system to restrict a user’s process from<br>
accessing, say, kernel memory, which, whether done accidentally or on purpose, could<br>
allow such a process to circumvent security mechanisms or even bring down the whole<br>
system.<br>
So, for backward compatibility, it is important that CPUs boot initially in16-bit<br>
real mode, requiring modern operating systems explicitly to switch up into the more<br>
advanced 32-bit (or 64-bit) protected mode, but allowing older operating systems to<br>
carry on, blissfully unaware that they are running on a modern CPU. Later on, we will<br>
look at this important step from 16-bit real mode into 32-bit protected mode in detail.<br>
Generally, when we say that a CPU is 16-bit, we mean that its instructions can work<br>
with a maximum of 16-bits at once, for example: a 16-bit CPU will have a particular<br>
instruction that can add two 16-bit numbers together in one CPU cycle; if it was neces-<br>
sary for a process to add together two 32-bit numbers, then it would take more cycles,<br>
that make use of 16-bit addition.<br>
First we will explore this 16-bit real mode environment, since all operating systems<br>
must begin here, then later we will see how to switch into 32-bit protected mode and the<br>
main benefits of doing so.</p>
<h3 id="erm-hello">3.3 Erm, Hello?</h3>
<p>Now we are going to write aseeminglysimple boot sector program that prints a short<br>
message on the screen. To do this we will have to learn some fundamentals of how the<br>
CPU works and how we can use BIOS to help us to manipulate the screen device.<br>
Firstly, let’s think about what we are trying to do here. We’d like to print a character<br>
on the screen but we do not know exactly how to communicate with the screen device,<br>
since there may be many different kinds of screen devices and they may have different<br>
interfaces. This is why we need to use BIOS, since BIOS has already done some auto<br>
detection of the hardware and, evidently by the fact that BIOS earlier printed information<br>
on the screen about self-testing and so on, so can offer us a hand.<br>
So, next, we’d like to ask BIOS to print a character for us, but how do we ask BIOS<br>
to do that? There are no Java libraries for printing to the screen — they are a dream<br>
away. We can be sure, however, that somewhere in the memory of the computer there<br>
will be some BIOS machine code that knows how to write to the screen. The truth is<br>
that we could possibly find the BIOS code in memory and execute it somehow, but this<br>
is more trouble than it is worth and will be prone to errors when there are differences<br>
between BIOS routine internals on different machines.<br>
Here we can make use of a fundamental mechanism of the computer:interrupts.</p>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 11</p>
<h4 id="interrupts">3.3.1 Interrupts</h4>
<p>Interrupts are a mechanism that allow the CPU temporarily to halt what it is doing and<br>
run some other, higher-priority instructions before returning to the original task. An<br>
interrupt could be raised either by a software instruction (e.g. int 0x10) or by some<br>
hardware device that requires high-priority action (e.g. to read some incoming data from<br>
a network device).<br>
Each interrupt is represented by a unique number that is an index to the interrupt<br>
vector, a table initially set up by BIOS at the start of memory (i.e. at physical address<br>
0x0) that contains address pointers tointerrupt service routines(ISRs). An ISR is simply<br>
a sequence of machine instructions, much like our boot sector code, that deals with a<br>
specific interrupt (e.g. perhaps to read new data from a disk drive or from a network<br>
card).<br>
So, in a nutshell, BIOS adds some of its own ISRs to the interrupt vector that<br>
specialise in certain aspects of the computer, for example: interrupt0x10causes the<br>
screen-related ISR to be invoked; and interrupt0x13, the disk-related I/O ISR.<br>
However, it would be wasteful to allocate an interrupt per BIOS routine, so BIOS<br>
multiplexes the ISRs by what we could imagine as a bigswitchstatement, based usually<br>
on the value set in one of the CPUs general purpose registers,ax, prior to raising the<br>
interrupt.</p>
<h4 id="cpu-registers">3.3.2 CPU Registers</h4>
<p>Just as we use variables in a higher level languages, it is useful if we can store data tem-<br>
porarily during a particular routine. All x86 CPUs have four general purposeregisters,<br>
ax,bx,cx, anddx, for exactly that purpose. Also, these registers, which can each hold<br>
aword(two bytes, 16 bits) of data, can be read and written by the CPU with negligible<br>
delay as compared with accessing main memory. In assembly programs, one of the most<br>
common operations is moving (or more accurately,copying) data between these registers:</p>
<pre><code>mov ax, 1234 ; store the decimal number 1234 in ax
mov cx, 0x234 ; store the hex number 0x234 in cx
mov dx, ’t’ ; store the ASCII code for letter ’t’ in dx
mov bx, ax ; copy the value of ax into bx, so now bx == 1234
</code></pre>
<p>Notice that the destination is the first and not second argument of themovoperation,<br>
but this convention varies with different assemblers.<br>
Sometimes it is more convenient to work with single bytes, so these registers let us<br>
set their high and low bytes independently:</p>
<pre><code>mov ax, 0 ; ax -&gt; 0x0000 , or in binary 0000000000000000
mov ah, 0x56 ; ax -&gt; 0x
mov al, 0x23 ; ax -&gt; 0x
mov ah, 0x16 ; ax -&gt; 0x
</code></pre>
<p>[?]</p>
<h4 id="putting-it-all-together">3.3.3 Putting it all Together</h4>
<p>So, recall that we’d like BIOS to print a character on the screen for us, and that we<br>
can invoke a specific BIOS routine by settingaxto some BIOS-defined value and then</p>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 12</p>
<p>triggering a specific interrupt. The specific routine we want is the BIOS scrolling tele-<br>
type routine, which will print a single character on the screen and advance the cursor,<br>
ready for the next character. There is a whole list of BIOS routines published that show<br>
you which interrupt to use and how to set the registers prior to the interrupt. Here, we<br>
need interrupt0x10and to setahto0x0e(to indicate tele-type mode) andalto the<br>
ASCII code of the character we wish to print.</p>
<pre><code>;
; A simple boot sector that prints a message to the screen using a BIOS routine.
;
</code></pre>
<pre><code>mov ah, 0x0e ; int 10/ah = 0eh -&gt; scrolling teletype BIOS routine
</code></pre>
<pre><code>mov al, ’H’
int 0x
mov al, ’e’
int 0x
mov al, ’l’
int 0x
mov al, ’l’
int 0x
mov al, ’o’
int 0x
</code></pre>
<pre><code>jmp $ ; Jump to the current address (i.e. forever).
</code></pre>
<pre><code>;
; Padding and magic BIOS number.
;
</code></pre>
<pre><code>times 510-($-$$) db 0 ; Pad the boot sector out with zeros
</code></pre>
<pre><code>dw 0xaa55 ; Last two bytes form the magic number ,
; so BIOS knows we are a boot sector.
</code></pre>
<p>Figure 3.2:</p>
<p>Figure 3.2 shows the whole boot sector program. Notice how, in this case, we only<br>
needed to setahonce, then just changedalfor different characters.</p>
<pre><code>b4 0e b0 48 cd 10 b0 65 cd 10 b0 6c cd 10 b0 6c
cd 10 b0 6f cd 10 e9 fd ff 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa
</code></pre>
<p>Figure 3.3:</p>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 13</p>
<p>Just for completeness, Figure 3.3 shows the raw machine code of this boot sector.<br>
These are the actual bytes that are telling the CPU exactly what to do. If you are<br>
surprised by the amount of effort and understanding that is involved in writing such a<br>
barely — if at all — useful program, then remember that these instructions map very<br>
closely to the CPU’s circuitry, so necessarily they are very simple, but also very fast.<br>
You are getting to know your computer now, as it reallyis.</p>
<h3 id="hello-world">3.4 Hello, World!</h3>
<p>Now we are going to attempt a slightly more advanced version of the ’hello’ program,<br>
that introduces a few more CPU fundamentals and an understanding of the landscape<br>
of memory into which our boot sector gets plonked by BIOS.</p>
<h4 id="memory-addresses-and-labels">3.4.1 Memory, Addresses, and Labels</h4>
<p>We said earlier how the CPU fetches and executes instructions from memory, and how it<br>
was BIOS that loaded our 512-byte boot sector into memory and then, having finished<br>
its initialisations, told the CPU to jump to the start of our code, whereupon it began<br>
executing our first instruction, then the next, then the next, etc.<br>
So our boot sector code is somewhere in memory; but where? We can imagine the<br>
main memory as long sequence of bytes that can individually be accessed by an address<br>
(i.e. an index), so if we want to find out what is in the 54th byte of memory, then 54 is<br>
our address, which is often more convenient to express in hexadecimal:0x36.<br>
So the start of our boot-sector code, the very first machine code byte, is at some<br>
address in memory, and it was BIOS that put us there. We might assume, unless we<br>
knew otherwise, that BIOS loaded our code at the start of memory, at address0x0. It’s<br>
not so straightforward, though, because we know that BIOS has already being doing<br>
initialisation work on the computer long before it loaded our code, and will actually<br>
continue to service hardware interrupts for the clock, disk drives, and so on. So these<br>
BIOS routines (e.g. ISRs, services for screen printing, etc.) themselves must be stored<br>
somewhere in memory and must be preserved (i.e. not overwritten) whilst they are<br>
still of use. Also, we noted earlier that the interrupt vector is located at the start of<br>
memory, and were BIOS to load us there, our code would stomp over the table, and upon<br>
the next interrupt occurring, the computer will likely crash and reboot: the mapping<br>
between interrupt number and ISR would effectively have been severed.<br>
As it turns out, BIOS likes always to load the boot sector to the address0x7c00,<br>
where it is sure will not be occupied by important routines. Figure 3.4 gives an example<br>
of the typical low memory layout of the computer when our boot sector has just been<br>
loaded [?]. So whilst we may instruct the CPU to write data to any address in memory,<br>
it may cause bad things to happen, since some memory is being used by other routines,<br>
such as the timer interrupt and disk devices.</p>
<h4 id="’x’-marks-the-spot">3.4.2 ’X’ Marks the Spot</h4>
<p>Now we are going to play a game called “find the byte”, which will demonstrate memory<br>
referencing, the use of labels in assembly code, and the importance of knowing where<br>
BIOS loaded us to. We are going to write an assembly program that reserves a byte of</p>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 14</p>
<p>Figure 3.4: Typical lower memory layout after boot.</p>
<p>data for a character, then we will try to print out that character on the screen. To do<br>
this we need to figure out its absolute memory address, so we can load it intoaland get<br>
BIOS to print it, as in the last exercise.</p>
<pre><code>;
; A simple boot sector program that demonstrates addressing.
;
mov ah, 0x0e ; int 10/ah = 0eh -&gt; scrolling teletype BIOS routine
</code></pre>
<pre><code>; First attempt
mov al, the_secret
int 0x10 ; Does this print an X?
</code></pre>
<pre><code>; Second attempt
mov al, [the_secret]
int 0x10 ; Does this print an X?
</code></pre>
<pre><code>; Third attempt
mov bx, the_secret
add bx, 0x7c
mov al, [bx]
int 0x10 ; Does this print an X?
</code></pre>
<pre><code>; Fourth attempt
</code></pre>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 15</p>
<pre><code>mov al, [0 x7c1e]
int 0x10 ; Does this print an X?
</code></pre>
<pre><code>jmp $ ; Jump forever.
</code></pre>
<pre><code>the_secret:
db "X"
; Padding and magic BIOS number.
</code></pre>
<pre><code>times 510-($-$$) db 0
dw 0xaa
</code></pre>
<p>Firstly, when we declare some data in our program, we prefix it with a label (thesecret).<br>
We can put labels anywhere in our programs, with their only purpose being to give us a<br>
convenient offset from the start of the code to a particular instruction or data.</p>
<pre><code>b4 0e b0 1e cd 10 a0 1e 00 cd 10 bb 1e 00 81 c
00 7c 8a 07 cd 10 a0 1e 7c cd 10 e9 fd ff 58 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa
</code></pre>
<p>Figure 3.5:</p>
<p>If we look at the assembled machine code in Figure 3.5, we can see that our ’X’,<br>
which has an hexadecimal ASCII code0x58, is at an offset of 30 (0x1e) bytes from the<br>
start of the code, immediately before we padded the boot sector with zeros.<br>
If we run the program we see that only the second two attempts succeed in printing<br>
an ’X’.<br>
The problem with the first attempt is that it tries to load the immediate offset into<br>
alas the character to print, but actually we wanted to print the characteratthe offset<br>
rather than the offset itself, as attempted next, whereby the square brackets instruct the<br>
CPU to do this very thing - store thecontentsof an address.<br>
So why does the second attempt fail? The problem is, that the CPU treats the offset<br>
as though it was from the start of memory, rather than the start address of our loaded<br>
code, which would land it around about in the interrupt vector. In the third attempt,<br>
we add the offsetthesecretto the address that we beleive BIOS to have loaded our<br>
code,0x7c00, using the CPUaddinstruction. We can think ofaddas the higher level<br>
language statementbx = bx + 0x7c00. We have now calculated the correct memory<br>
address of our ’X’ and can store the contents of that address inal, ready for the BIOS<br>
print function, with the instructionmov al, [bx].<br>
In the fourth attempt we try to be a bit clever, by pre-calculating the address of the<br>
’X’ after the boot sector is loaded into memory by BIOS. We arrive at the address0x7c1e<br>
based on our earlier examination of the binary code (See Figure 3.5) which revealed that<br>
’X’ was0x1e(30) bytes from the start of our boot sector. This last example reminds</p>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 16</p>
<p>us why labels are useful, since without labels we would have to count offsets from the<br>
compiled code, and then update these when changes in code cause these offsets to change.<br>
So now we have seen how BIOS does indeed load our boot sector to the address<br>
0x7c00, and we have also seen how addressing and assembly code labels are related.<br>
It is inconvenient to always have to account for this label–memory offset in your<br>
code, so many assemblers will correct label references during assemblege if you include<br>
the following instruction at the top of your code, telling it exactly where you expect the<br>
code to loaded in memory:</p>
<pre><code>[org 0x7c00]
</code></pre>
<p>Question 1</p>
<p>What do you expect will be printed now, when thisorgdirective is added to this boot-<br>
sector program? For good marks, explain why this is so.</p>
<h4 id="defining-strings">3.4.3 Defining Strings</h4>
<p>Supposing you wanted to print a pre-defined message (e.g. “Booting OS”) to the screen<br>
at some point; how would you define such a string in your assembly program? We have<br>
to remind ourselves that our computer knows nothing about strings, and that a string<br>
is merely a sequence of data units (e.g. bytes, words, etc.) held somewhere in memory.<br>
In the assembler we can define a string as follows:<br>
my_string:<br>
db ’Booting OS’</p>
<p>We’ve actually already seendb, which translates to “declare byte(s) of data”, which tells<br>
the assembler to write the subsequent bytes directly to the binary output file (i.e. do not<br>
interpret them as processor instructions). Since we surrounded our data with quotes,<br>
the assembler knows to convert each character to its ASCII byte code. Note that, we<br>
often use a label (e.g. mystring) to mark the start of our data, otherwise we would<br>
have no easy way of referencing it within our code.<br>
One thing we have overlooked in this example is that knowing howlonga string<br>
is equally important as to knowing where it is. Since it is us that has to write all the<br>
code that handles strings, it is important to have a consistent strategy for knowing how<br>
long a string is. There are a few possibilities, but the convention is to declare strings<br>
asnull-terminating, which means we always declare the last byte of the string as 0 , as<br>
follows:</p>
<pre><code>my_string:
db ’Booting OS’,
</code></pre>
<p>When later iterating through a string, perhaps to print each of its characters in turn, we<br>
can easily determine when we have reached the end.</p>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 17</p>
<h4 id="using-the-stack">3.4.4 Using the Stack</h4>
<p>When on the topic of low-level computing, we often hear people talking about thestack<br>
like it is some special thing. The stack is really just a simple solution to the following<br>
inconvenience: the CPU has a limited number of registers for the temporary storage of<br>
our routine’s local variables, but we often need more temporary storage than will fit into<br>
these registers; now, we can obviously make use of main memory, but specifying specific<br>
memory addresses when reading and writing is inconvenient, especially since we do not<br>
care exactly where the data is to be stored, only that we can retrieve it easily enough.<br>
And, as we shall see later, the stack is also useful for argument passing to realise function<br>
calls.<br>
So, the CPU offers two instructionspushandpopthat allow us, respectively, to store<br>
a value and retrieve a value from the top of the stack, and so without worrying exactly<br>
where they are stored. Note, however, that we cannot push and pop single bytes onto<br>
and off the stack: in 16-bit mode, the stack works only on 16-bit boundaries.<br>
The stack is implemented by two special CPU registers,bpandsp, which maintain<br>
the addresses of the stack base (i.e. the stack bottom) and the stack top respectively.<br>
Since the stack expands as we push data onto it, we usually set the stack’s base far away<br>
from important regions of memory (e.g. such as BIOS code or our code) so their is no<br>
danger of overwriting if the stack grows too large. One confusing thing about the stack<br>
is that it actually growsdownwardsfrom the base pointer, so when we issue apush,<br>
the value actually gets stored below — and not above — the address ofbp, andspis<br>
decremented by the value’s size.<br>
The following boot sector program in Figure 3.6 demonstrates use of the stack.</p>
<p>Question 2</p>
<p>What will be printed in what order by the code in Figure 3.6? And at what absolute<br>
memory address will the ASCII character ’C’ be stored? You may find it useful to modify<br>
the code to confirm your expectation, but be sure to explainwhyit is this address.</p>
<h4 id="control-structures">3.4.5 Control Structures</h4>
<p>We’d never be comfortable using a programming language if we didn’t know how to<br>
write some basic control structures, such asif…then…elseif…else,for, andwhile.<br>
These structures allow alternative branches of execution and form the basis of any useful<br>
routine.<br>
After compilation, these high-level control structures reduce to simple jump state-<br>
ments. Actually, we’ve already seen the simplest example of loops:</p>
<pre><code>some_label:
jmp some_label ; jump to address of label
</code></pre>
<p>Or alternatively, with identical effect:</p>
<pre><code>jmp $ ; jump to address of current instruction
</code></pre>
<p>So this instruction offers us anunconditionaljump (i.e. it willalwaysjump); but we<br>
often need to jump based on some condition (e.g. carry on loopinguntil we have looped<br>
ten times, etc.).</p>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 18</p>
<pre><code>;
; A simple boot sector program that demonstrates the stack.
;
mov ah, 0x0e ; int 10/ah = 0eh -&gt; scrolling teletype BIOS routine
</code></pre>
<pre><code>mov bp, 0x8000 ; Set the base of the stack a little above where BIOS
mov sp, bp ; loads our boot sector - so it won’t overwrite us.
push ’A’ ; Push some characters on the stack for later
push ’B’ ; retreival. Note , these are pushed on as
push ’C’ ; 16-bit values , so the most significant byte
; will be added by our assembler as 0x00.
</code></pre>
<pre><code>pop bx ; Note , we can only pop 16-bits , so pop to bx
mov al, bl ; then copy bl (i.e. 8-bit char) to al
int 0x10 ; print(al)
</code></pre>
<pre><code>pop bx ; Pop the next value
mov al, bl
int 0x10 ; print(al)
mov al, [0 x7ffe] ; To prove our stack grows downwards from bp ,
; fetch the char at 0x8000 - 0x2 (i.e. 16-bits)
int 0x10 ; print(al)
</code></pre>
<pre><code>jmp $ ; Jump forever.
</code></pre>
<pre><code>; Padding and magic BIOS number.
</code></pre>
<pre><code>times 510-($-$$) db 0
dw 0xaa55
</code></pre>
<p>Figure 3.6: Manipulation of the stack, usingpushandpop</p>
<p>Conditional jumps are achieved in assembly language by first running a comparison<br>
instruction, then by issuing a specific conditional jump instruction.</p>
<pre><code>cmp ax, 4 ; compare the value in ax to 4
je then_block ; jump to then_block if they were equal
mov bx, 45 ; otherwise , execute this code
jmp the_end ; important: jump over the ’then’ block ,
; so we don’t also execute that code.
then_block:
mov bx, 23
the_end:
</code></pre>
<p>In a language such as C or Java, this would look like this:</p>
<pre><code>if(ax == 4) {
bx = 23;
} else {
bx = 45;
}
</code></pre>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 19</p>
<p>We can see from the assembly example that there is something going on behind the<br>
scenes that is relating thecmpinstruction to thejeinstruction it proceeds. This is an<br>
example of where the CPU’s specialflagsregister is used to capture the outcome of<br>
thecmpinstruction, so that a subsequent conditional jump instruction can determine<br>
whether or not to jump to the specified address.<br>
The following jump instructions are available, based on an earliercmp x, yinstruc-<br>
tion:</p>
<pre><code>je target ; jump if equal (i.e. x == y)
jne target ; jump if not equal (i.e. x != y)
jl target ; jump if less than (i.e. x &lt; y)
jle target ; jump if less than or equal (i.e. x &lt;= y)
jg target ; jump if greater than (i.e. x &gt; y)
jge target ; jump if greater than or equal (i.e. x &gt;= y)
</code></pre>
<p>Question 3</p>
<p>It’s always useful to plan your conditional code in terms of a higher level language, then<br>
replace it with the assembly instructions. Have a go at converting this pseudo assembly<br>
code into full assembly code, usingcmpand appropriate jump instructions. Test it with<br>
different values ofbx. Fully comment your code, in your own words.</p>
<pre><code>mov bx, 30
</code></pre>
<pre><code>if (bx &lt;= 4) {
mov al, ’A’
} else if (bx &lt; 40) {
mov al, ’B’
} else {
mov al, ’C’
}
</code></pre>
<pre><code>mov ah, 0x0e ; int =10/ah=0x0e -&gt; BIOS tele -type output
int 0x10 ; print the character in al
</code></pre>
<pre><code>jmp $
</code></pre>
<pre><code>; Padding and magic number.
times 510-($-$$) db 0
dw 0xaa55
</code></pre>
<h4 id="calling-functions">3.4.6 Calling Functions</h4>
<p>In high-level languages, we break big problems down into functions, which essentially<br>
are general purpose routines (e.g. print a message, write to a file, etc.) that we use<br>
over and over again throughout our program, usually changing parameters that we pass<br>
to the function to change the outcome in some way. At the CPU level a function is<br>
nothing more than a jump to the address of a useful routine then a jump back again to<br>
the instruction immediately following the first jump.<br>
We can kind of simulate a function call like this:</p>
<pre><code>...
...
mov al, ’H’ ; Store ’H’ in al so our function will print it.
</code></pre>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 20</p>
<pre><code>jmp my_print_function
return_to_here: ; This label is our life -line so we can get back.
...
...
</code></pre>
<pre><code>my_print_function:
mov ah, 0x0e ; int =10/ah=0x0e -&gt; BIOS tele -type output
int 0x10 ; print the character in al
jmp return_to_here ; return from the function call.
</code></pre>
<p>Firstly, note how we used the registeralas a parameter, by setting it up ready for<br>
the function to use. This is how parameter passing is made possible in higher level<br>
languages, where thecallerandcallee must have some agreement on where and how<br>
many parameters will be passed.<br>
Sadly, the main flaw with this approach is that we need to say explicitly where to<br>
return to after our function has been called, and so it will not be possible to call this<br>
function from arbitrary points in our program — it will always return the same address,<br>
in this case the labelreturntohere.<br>
Borrowing from the parameter passing idea, the caller code could store the correct<br>
return address (i.e. the address immediately after the call) in some well-known location,<br>
then the called code could jump back to that stored address. The CPU keeps track of the<br>
current instruction being executed in the special registerip(instruction pointer), which,<br>
sadly, we cannot access directly. However, the CPU provides a pair of instructions,call<br>
andret, which do exactly what we want:callbehaves likejmpbut additionally, before<br>
actually jumping, pushes the return address on to the stack;retthen pops the return<br>
address off the stack and jumps to it, as follows:</p>
<pre><code>...
...
mov al, ’H’ ; Store ’H’ in al so our function will print it.
call my_print_function
...
...
</code></pre>
<pre><code>my_print_function:
mov ah, 0x0e ; int =10/ah=0x0e -&gt; BIOS tele -type output
int 0x10 ; print the character in al
ret
</code></pre>
<p>Our functions are almost self-contained now, but there is a still an ugly problem that we<br>
will thank ourselves later for if we now take the trouble to consider it. When we call a<br>
function, such as a print function, within our assembly program, internally that function<br>
may alter the values of several registers to perform its job (indeed, with registers being<br>
a scarce resource, it will almost certainly do this), so when our program returns from<br>
the function call it may not be safe to assume, say, the value we stored indxwill still be<br>
there.<br>
It is often sensible (and polite), therefore, for a function immediately to push any<br>
registers it plans to alter onto the stack and then pop them off again (i.e. restore the<br>
registers’ original values) immediately before it returns. Since a function may use many<br>
of the general purpose registers, the CPU implements two convenient instructions,pusha<br>
andpopa, that conveniently push and popallregisters to and from the stack respectively,<br>
for example:</p>
<pre><code>...
</code></pre>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 21</p>
<pre><code>some_function:
pusha ; Push all register values to the stack
mov bx, 10
add bx, 20
mov ah, 0x0e ; int =10/ah=0x0e -&gt; BIOS tele -type output
int 0x10 ; print the character in al
popa ; Restore original register values
ret
</code></pre>
<h4 id="include-files">3.4.7 Include Files</h4>
<p>After slaving away even on the seemingly simplest of assembly routines, you will likely<br>
want to reuse your code in multiple programs. nasm allows you to include external files<br>
literally as follows:</p>
<pre><code>%include "my_print_function.asm" ; this will simply get replaced by
; the contents of the file
</code></pre>
<pre><code>mov al, ’H’ ; Store ’H’ in al so our function will print it.
call my_print_function
</code></pre>
<h4 id="putting-it-all-together-1">3.4.8 Putting it all Together</h4>
<p>We now have enough knowledge about the CPU and assembly to write a more sophisti-<br>
cated “Hello, World” boot sector program.</p>
<p>Question 4</p>
<p>Put together all of the ideas in this section to make a self-contained function for printing<br>
null-terminated strings, that can be used as follows:</p>
<pre><code>;
; A boot sector that prints a string using our function.
;
[org 0x7c00] ; Tell the assembler where this code will be loaded
</code></pre>
<pre><code>mov bx, HELLO_MSG ; Use BX as a parameter to our function , so
call print_string ; we can specify the address of a string.
</code></pre>
<pre><code>mov bx, GOODBYE_MSG
call print_string
</code></pre>
<pre><code>jmp $ ; Hang
</code></pre>
<pre><code>%include "print_string.asm"
</code></pre>
<pre><code>; Data
HELLO_MSG:
db ’Hello , World!’, 0 ; &lt;-- The zero on the end tells our routine
</code></pre>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 22</p>
<pre><code>; when to stop printing characters.
GOODBYE_MSG:
db ’Goodbye!’, 0
</code></pre>
<pre><code>; Padding and magic number.
times 510-($-$$) db 0
dw 0xaa55
</code></pre>
<p>For good marks, make sure the function is careful when modifying registers and that<br>
you fully comment the code to demonstrate your understanding.</p>
<h4 id="summary">3.4.9 Summary</h4>
<p>Still, it feels that we have not come very far. That’s okay, and that’s quite normal, given<br>
the primitive environment that we have been working in. If you have understood all up<br>
until here, then we are well on our way.</p>
<h3 id="nurse-fetch-me-my-steth-o-scope">3.5 Nurse, Fetch me my Steth-o-scope</h3>
<p>So far we have managed to get the computer to print out characters and strings that we<br>
have loaded into memory, but soon we will be trying to load some data from the disk,<br>
so it will be very helpful if we can display the hexadecimal values stored at aribitrary<br>
memory addresses, to confirm if we have indeed managed to load anything. Remember,<br>
we do not have the luxury of a nice development GUI, complete with a debugger that will<br>
let us carefully step though and inspect our code, and the best feedback the computer<br>
can give us when we make a mistake is visibly to do nothing at all, so we need to look<br>
after ourselves.<br>
We have already written a routine to print out a string of characters, so we will<br>
now extend that idea into a hexadecimal printing routine — a routine certainly to be<br>
cherished in this unforgiving, low-level world.<br>
Let’s think carefully about how we will do this, starting by considering how we’d like<br>
to use the routine. In a high-level language, we’d like something like this:printhex(0x1fb6),<br>
which would result in the string’0x1fb6’being printed on the screen. We have already<br>
seen, in Section XXX, how functions can be called in assembly and how we can use<br>
registers as parameters, so let’s use thedxregister as a parameter to hold the value we<br>
wish our printhex function to print:</p>
<pre><code>mov dx, 0x1fb6 ; store the value to print in dx
call print_hex ; call the function
</code></pre>
<pre><code>; prints the value of DX as hex.
print_hex:
...
...
ret
</code></pre>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 23</p>
<p>Since we are printing a string to the screen, we might as well re-use our earlier printing<br>
function to do the actual printing part, then our main task is to look at how we can build<br>
that string from the value in our parameter,dx. We definitely don’t want to confuse<br>
matters more than we need to when working in assembly, so let’s consider the following<br>
trick to get us started with this function. If we define the complete hexadecimal string as<br>
a sort of template variable in our code, as we defined our earlier “Hello, World” messages,<br>
we can simply get the string printing function to print it, then the task of ourprinthex<br>
routine is to alter the components of that template string to reflect the hexadecimal<br>
value as ASCII codes:</p>
<pre><code>mov dx, 0x1fb6 ; store the value to print in dx
call print_hex ; call the function
</code></pre>
<pre><code>; prints the value of DX as hex.
print_hex:
; TODO: manipulate chars at HEX_OUT to reflect DX
</code></pre>
<pre><code>mov bx, HEX_OUT ; print the string pointed to
call print_string ; by BX
ret
</code></pre>
<pre><code>; global variables
HEX_OUT: db ’0x0000 ’,0
</code></pre>
<h4 id="question-5-advanced">3.5.1 Question 5 (Advanced)</h4>
<p>Complete the implementation of theprinthexfunction. You may find the CPU instruc-<br>
tionsandandshrto be useful, which you can find information about on the Internet.<br>
Make sure to fully explain your code with comments, in your own words.</p>
<h3 id="reading-the-disk">3.6 Reading the Disk</h3>
<p>We have now been introduced to BIOS, and have had a little play in the computer’s<br>
low-level environment, but we have a little problem that poses to get in the way of our<br>
plan to write an operating system: BIOS loaded our boot code from the first sector of<br>
the disk, but that isallit loaded; what if our operating system code is larger — and I’m<br>
guessing it will be — than 512 bytes.<br>
Operating systems usually don’t fit into a single (512 byte) sector, so one of the first<br>
things they must do is bootstrap the rest of their code from the disk into memory and<br>
then begin executing that code. Luckily, as was hinted at earlier, BIOS provides routines<br>
that allow us to manipulate data on the drives.</p>
<h4 id="extended-memory-access-using-segments">3.6.1 Extended Memory Access Using Segments</h4>
<p>When the CPU runs in its intial 16-bit real mode, the maximum size of the registers is 16<br>
bits, which means that the highest address we can reference in an instruction is0xffff,<br>
which amounts by today’s standards to a measily 64 KB (65536 bytes). Now, perhaps<br>
the likes of our intended simple operating system would not be affected by this limit,</p>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 24</p>
<p>but a day-to-day operating systems would never sit comfortably in such a tight box, so<br>
it is important that we understand the solution, of segmentation, to this problem.<br>
To get around this limitation, the CPU designers added a few more special registers,<br>
cs,ds,ss, andes, calledsegment registers. We can imagine main memory as being<br>
divided intosegments that are indexed by the segment registers, such that, when we<br>
specify a 16-bit address, the CPU automatically calculates the absolute address as the<br>
appropriate segment’s start address offseted by our specified address [?]. Byappropriate<br>
segment, I mean that, unless explicitly told otherwise, the CPU will offset our address<br>
from the segment register appropriate for the context of our instruction, for example:<br>
the address used in the instructionmov ax, [0x45ef]would by default be offset from<br>
thedata segment, indexed byds; similarly, thestack segment,ss, is used to modify the<br>
actual location of the stack’s base pointer,bp.<br>
The most confusing thing about segment addressing is that adjacent segments overlap<br>
almost completely but for 16 bytes, so different segment and offset combinations can<br>
actually point to the same physical address; but enough of the talk: we won’t truly<br>
grasp this concept until we’ve seen some examples.<br>
To calculate the absolute address the CPU multiplies the value in the segment register<br>
by 16 and then adds your offset address; and because we are working with hexadecimal,<br>
when we multiple a number by 16, we simply shift it a digit to the left (e.g.0x42* 16<br>
=0x420). So if we setdsto0x4dand then issue the statementmov ax, [0x20], the<br>
value stored inaxwill actually be loaded from address0x4d0(16 <em>0x4d+0x20).<br>
Figure 3.7 shows how we can setdsto achieve a similar correction of label addressing<br>
as when we used the[org 0x7c00]directive in Section XXX. Because we do not use the<br>
orgdirective, the assmebler does not offset our labels to the correct memory locations<br>
when the code is loaded by BIOS to the address0x7c00, so the first attempt to print an<br>
’X’ will fail. However, if we set the data segment register to0x7c0, the CPU will do this<br>
offset for us (i.e. 0x7c0</em> 16 +thesecret), and so the second attempt will correctly<br>
print the ’X’. In the third and fourth attempts we do the same, and get the same results,<br>
but instead explicitly state to the CPU which segment register to use when computing<br>
the physical address, using instead the general purpose segment registeres.<br>
Note that limitations of the CPU’s circuitry (at least in 16-bit real mode) reveal<br>
themselves here, when seemingly correct instructions likemov ds, 0x1234are not actu-<br>
ally possibly: just because we can store a literal address directly into a general purpose<br>
register (e.g.mov ax, 0x1234ormov cx, 0xdf), it doesn’t mean we can do the same<br>
with every type of register, such as segment registers; and so, as in Figure 3.7, we must<br>
take an additional step to transfer the value via a general purpose register.<br>
So, segment-based addressing allows us to reach further into memory, up to a little<br>
over 1 MB (0xffff* 16 +0xffff). Later, we will see how more memory can be accessed,<br>
when we switch to 32-bit protected mode, but for now it suffices for us to understand<br>
16-bit real mode segment-based addressing.</p>
<h4 id="how-disk-drives-work">3.6.2 How Disk Drives Work</h4>
<p>Mechanically, hard disk drives contain one or more stacked platters that spin under a<br>
read/write head, much like an old record player, only potentially, to increase capacity,<br>
with several records stacked one above the other, where a head moves in and out to get<br>
coverage of the whole of a particular spinning platter’s surface; and since a particular<br>
platter may be readible and writable on both of its surfaces, one read/write head may</p>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 25</p>
<pre><code>;
; A simple boot sector program that demonstrates segment offsetting
;
mov ah, 0x0e ; int 10/ah = 0eh -&gt; scrolling teletype BIOS routine
</code></pre>
<pre><code>mov al, [the_secret]
int 0x10 ; Does this print an X?
mov bx, 0x7c0 ; Can’t set ds directly , so set bx
mov ds, bx ; then copy bx to ds.
mov al, [the_secret]
int 0x10 ; Does this print an X?
</code></pre>
<pre><code>mov al, [es:the_secret] ; Tell the CPU to use the es (not ds) segment.
int 0x10 ; Does this print an X?
</code></pre>
<pre><code>mov bx, 0x7c0
mov es, bx
mov al, [es:the_secret]
int 0x10 ; Does this print an X?
jmp $ ; Jump forever.
</code></pre>
<pre><code>the_secret:
db "X"
</code></pre>
<pre><code>; Padding and magic BIOS number.
times 510-($-$$) db 0
dw 0xaa55
</code></pre>
<p>Figure 3.7: Manipulating the data segment with thedsregister.</p>
<p>float above and another below it. Figure 3.8 shows the inside of a typical hard disk<br>
drive, with the stack of platters and heads exposed. Note that the same idea applies to<br>
floppy disk drives, which, instead of several stacked hard platters, usually have a single,<br>
two-sided floppy disk medium.<br>
The metalic coating of the platters give them the property that specific areas of their<br>
surface can be magnetised or demagnetised by the head, effectively allowing any state<br>
to be recorded permanently on them [?]. It is therefore important to be able to describe<br>
the exact place on the disk’s surface where some state is to be read or written, and<br>
so Cylinder-Head-Sector (CHS) addressing is used, which effectively is a 3D coordinate<br>
system (see Figure 3.9):</p>
<ul>
<li>Cylinder: the cylinder describes the head’s discrete distance from the outer edge<br>
of the platter and is so named since, when several platters are stacked up, you<br>
can visualise that all of the heads select a cylinder through all of the platters</li>
<li>Head: the head describes which track (i.e. which specific platter surface within<br>
the cylinder) we are interested in.</li>
<li>Sector: the circular track is divided into sectors, usually of capacity 512 bytes,<br>
which can be referenced with a sector index.</li>
</ul>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 26</p>
<p>Figure 3.8: Inside of a hard disk drive</p>
<p>Figure 3.9: Cylinder, Head, Sector structure of a hard disk.</p>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 27</p>
<h4 id="using-bios-to-read-the-disk">3.6.3 Using BIOS to Read the Disk</h4>
<p>As we will see a little later on, specific devices require specific routines to be written<br>
to use them, so, for example, a floppy disk device requires us to explicitly turn on and<br>
off the motor that spins the disk under the read-and-write head before we can use it,<br>
whereas most hard disk devices have more functionality automated on local chips [?], but<br>
again the bus technologies with which such devices connect to the CPU (e.g. ATA/IDE,<br>
SATA, SCSI, USB, etc.) affect how we access them. Thankfully, BIOS can offer a few<br>
disk routines that abstract all of these differences for common disk devices.<br>
The specific BIOS routine we are interested in here is accessed by raising interrupt<br>
0x13after setting the registeralto0x02. This BIOS routine expects us to set up a few<br>
other registers with details of which disk device to use, which blocks we wish to read<br>
from the disk, and where to store the blocks in memory. The most difficult part of using<br>
this routine is that we must specify the first block to be read using a CHS addressing<br>
scheme; otherwise, it is just a case of filling in the expected registers, as detailed in the<br>
next code snippet.</p>
<pre><code>mov ah, 0x02 ; BIOS read sector function
</code></pre>
<pre><code>mov dl, 0 ; Read drive 0 (i.e. first floppy drive)
mov ch, 3 ; Select cylinder 3
mov dh, 1 ; Select the track on 2nd side of floppy
; disk , since this count has a base of 0
mov cl, 4 ; Select the 4th sector on the track - not
; the 5th , since this has a base of 1.
mov al, 5 ; Read 5 sectors from the start point
</code></pre>
<pre><code>; Lastly , set the address that we’d like BIOS to read the
; sectors to, which BIOS expects to find in ES:BX
; (i.e. segment ES with offset BX).
mov bx, 0xa000 ; Indirectly set ES to 0xa000
mov es, bx
mov bx, 0x1234 ; Set BX to 0x1234
; In our case , data will be read to 0xa000:0x1234 , which the
; CPU will translate to physical address 0xa1234
</code></pre>
<pre><code>int 0x13 ; Now issue the BIOS interrupt to do the actual read.
</code></pre>
<p>Note that, for one reason or another (e.g. we indexed a sector beyond the limit of the<br>
disk, an attempt was made to read a faulty sector, the floppy disk was not inserted into<br>
the drive, etc.), BIOS may fail to read the disk for us, so it is important to know how<br>
to detect this; otherwise, we maythinkwe have read some data but in fact the target<br>
address simply contains the same random bytes it did before we issued the read command.<br>
Fortunately for us, BIOS updates some registers to let us know what happened: the carry<br>
flag (CF) of the specialflagsregister is set to signal a general fault, andalis set to the<br>
number of sectorsactuallyread, as opposed to the number requested. After issuing the<br>
interrupt for the BIOS disk read, we can perform a simple check as follows:</p>
<pre><code>...
...
int 0x13 ; Issue the BIOS interrupt to do the actual read.
</code></pre>
<pre><code>jc disk_error ; jc is another jumping instruction , that jumps
; only if the carry flag was set.
</code></pre>
<pre><code>; This jumps if what BIOS reported as the number of sectors
</code></pre>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 28</p>
<pre><code>; actually read in AL is not equal to the number we expected.
cmp al, &lt;no. sectors expected &gt;
jne disk_error
</code></pre>
<pre><code>disk_error :
mov bx, DISK_ERROR_MSG
call print_string
jmp $
</code></pre>
<pre><code>; Global variables
DISK_ERROR_MSG: db "Disk read error!", 0
</code></pre>
<h4 id="putting-it-all-together-2">3.6.4 Putting it all Together</h4>
<p>As explained earlier, being able to read more data from the disk will be essential for boot-<br>
strapping our operating system, so here we will put all of the ideas from this section into<br>
a helpful routine that will simply read the firstnsectors following the boot sector from<br>
a specified disk device.</p>
<pre><code>; load DH sectors to ES:BX from drive DL
disk_load:
push dx ; Store DX on stack so later we can recall
; how many sectors were request to be read ,
; even if it is altered in the meantime
mov ah, 0x02 ; BIOS read sector function
mov al, dh ; Read DH sectors
mov ch, 0x00 ; Select cylinder 0
mov dh, 0x00 ; Select head 0
mov cl, 0x02 ; Start reading from second sector (i.e.
; after the boot sector)
int 0x13 ; BIOS interrupt
</code></pre>
<pre><code>jc disk_error ; Jump if error (i.e. carry flag set)
</code></pre>
<pre><code>pop dx ; Restore DX from the stack
cmp dh, al ; if AL (sectors read) != DH (sectors expected)
jne disk_error ; display error message
ret
</code></pre>
<pre><code>disk_error :
</code></pre>
<pre><code>mov bx, DISK_ERROR_MSG
call print_string
jmp $
</code></pre>
<pre><code>; Variables
DISK_ERROR_MSG db "Disk read error!", 0
</code></pre>
<pre><code>And to test this routine, we can write a boot sector program as follows:
</code></pre>
<p>CHAPTER 3. BOOT SECTOR PROGRAMMING (IN 16-BIT REAL</p>
<p>MODE) 29</p>
<pre><code>; Read some sectors from the boot disk using our disk_read function
[org 0x7c00]
</code></pre>
<pre><code>mov [BOOT_DRIVE], dl ; BIOS stores our boot drive in DL, so it’s
; best to remember this for later.
</code></pre>
<pre><code>mov bp, 0x8000 ; Here we set our stack safely out of the
mov sp, bp ; way , at 0x8000
</code></pre>
<pre><code>mov bx, 0x9000 ; Load 5 sectors to 0x0000(ES):0 x9000(BX)
mov dh, 5 ; from the boot disk.
mov dl, [BOOT_DRIVE]
call disk_load
</code></pre>
<pre><code>mov dx, [0 x9000] ; Print out the first loaded word , which
call print_hex ; we expect to be 0xdada , stored
; at address 0x9000
</code></pre>
<pre><code>mov dx, [0 x9000 + 512] ; Also , print the first word from the
call print_hex ; 2nd loaded sector: should be 0xface
jmp $
</code></pre>
<pre><code>%include "../print/print_string.asm" ; Re -use our print_string function
%include "../hex/print_hex.asm" ; Re-use our print_hex function
%include "disk_load.asm"
; Include our new disk_load function
</code></pre>
<pre><code>; Global variables
BOOT_DRIVE: db 0
</code></pre>
<pre><code>; Bootsector padding
times 510-($-$$) db 0
dw 0xaa55
</code></pre>
<pre><code>; We know that BIOS will load only the first 512-byte sector from the disk ,
; so if we purposely add a few more sectors to our code by repeating some
; familiar numbers , we can prove to ourselfs that we actually loaded those
; additional two sectors from the disk we booted from.
times 256 dw 0xdada
times 256 dw 0xface
</code></pre>
<h1 id="chapter-4">Chapter 4</h1>
<h1 id="entering-32-bit-protected-mode">Entering 32-bit Protected Mode</h1>
<p>It would be nice to continue working in the 16-bit real mode with which we have now<br>
become much better aquainted, but in order to make fuller use of the CPU, and to<br>
better understand how developments of CPU architecures can benefit modern operating<br>
systems, namely memory protection in hardware, then we must press on into 32-bit<br>
protected mode.<br>
The main differences in 32-bit protected mode are:</p>
<ul>
<li>Registers are extended to 32 bits, with their full capacity being accessed by pre-<br>
fixing aneto the register name, for example:mov ebx, 0x274fe8fe</li>
<li>For convenience, there are two additional general purpose segment registers,fs<br>
andgs.</li>
<li>32-bit memory offsets are available, so an offset can reference a whopping 4 GB<br>
of memory (0xffffffff).</li>
<li>The CPU supports a more sophisticated — though slightly more complex —<br>
means of memory segmentation, which offers two big advantages:<br>
- Code in one segment can be prohibited from executing code in a more priv-<br>
ilidged segment, so you can protect your kernel code from user applications<br>
- The CPU can implementvirtual memoryfor user processes, such thatpages<br>
(i.e. fixed-sized chunks) of a process’s memory can be swapped transparently<br>
between the disk and memory on an as-needed basis. This ensure main<br>
memory is used efficiently, in that code or data that is rarely executed<br>
needn’t hog valuable memory.</li>
<li>Interrupt handling is also more sophisticated.<br>
[?]<br>
The most difficult part about switching the CPU from 16-bit real mode into 32-bit<br>
protected mode is that we must prepare a complex data structure in memory called the<br>
global descriptor table(GDT), which defines memory segments and their protected-mode<br>
attributes. Once we have defined the GDT, we can use a special instruction to load it</li>
</ul>
<p>30</p>
<p>CHAPTER 4. ENTERING 32-BIT PROTECTED MODE 31</p>
<p>into the CPU, before setting a single bit in a special CPU control register to make the<br>
actual switch.<br>
This process would be easy enough if we didn’t have to define the GDT in assembly<br>
language, but sadly this low-level switch-over is unavoidable if we later wish to load a<br>
kernel that has been compiled from a higher-level language such as C, which usually will<br>
be compiled to 32-bit instructions rather than the less-efficient 16-bit instructions.<br>
Oh, there is one shocker that I nearly forgot to mention: we can no longer use<br>
BIOS once switched into 32-bit protected mode. If you thought making BIOS calls was<br>
low-level. This is like one step backwards, two steps forwards.</p>
<h3 id="adapting-to-life-without-bios">4.1 Adapting to Life Without BIOS</h3>
<p>It is true: in our quest to make full use of the CPU, we must abandon all of those helpful<br>
routines provided by BIOS. As we will see when we look in more detail at the 32-bit<br>
protected mode switch-over, BIOS routines, having been coded to work only in 16-bit<br>
real mode, are no longer valid in 32-bit protected mode; indeed, attempting to use them<br>
would likely crash the machine.<br>
So what this means is that a 32-bit operating system must provide its own drivers for<br>
all hardware of the machine (e.g. the keybaord, screen, disk drives, mouse, etc). Actually,<br>
it is possible for a 32-bit protected mode operating system to switch temporarily back<br>
into 16-bit mode whereupon it may utilise BIOS, but this teachnique can be more trouble<br>
than it is worth, especially in terms of performance.<br>
The first problem we will encounted in switching to protected mode is knowing how<br>
to print a message on the screen, so we can see what is happening. Previously we<br>
have asked BIOS to print an ASCII character on the screen, but how did that result in<br>
the appropriate pixels being highlighted at the appropriate position of our computer’s<br>
screen? For now, it suffices to know that the display device can be configured into one<br>
of several resolutions in one of two modes,text modeandgraphics mode; and that what<br>
is displayed on the screen is a visual representation of a specific range of memory. So,<br>
in order to manipulate the screen, we must manipulate the specific memory range that<br>
it is using in its current mode. The display device is an example of memory-mapped<br>
hardware because it works in this way.<br>
When most computers boot, despite that they may infact have more advanced graph-<br>
ics hardware, they begin in a simple Video Graphics Array (VGA) colour text mode with<br>
dimmensions 80x25 characters. In text mode, the programmer does not need to render<br>
individual pixels to describe specific characters, since a simple font is already defined<br>
in the internal memory of the VGA display device. Instead, each character cell of the<br>
screen is represented by two bytes in memory: the first byte is the ASCII code of the<br>
character to be displayed, and the second byte encodes the characters attributes, such<br>
as the foreground and background colour and if the character should be blinking.<br>
So, if we’d like to display a character on the screen, then we need to set its ASCII<br>
code and attributes at the correct memory address for the current VGA mode, which<br>
is usually at address0xb8000. If we slightly modify our original (16-bit real mode)<br>
printstring routine so that it no longer uses the BIOS routine, we can create a 32-bit<br>
protected mode routine that writes directly to video memory, as in Figure 4.1.<br>
Note that, although the screen is displayed as columns and rows, the video memory<br>
is simply sequential. For example, the address of the column 5 on row 3 can be calculated<br>
as follows:0xb8000 + 2 * (row * 80 + col)</p>
<p>CHAPTER 4. ENTERING 32-BIT PROTECTED MODE 32</p>
<pre><code>[bits 32]
; Define some constants
VIDEO_MEMORY equ 0xb8000
WHITE_ON_BLACK equ 0x0f
</code></pre>
<pre><code>; prints a null -terminated string pointed to by EDX
print_string_pm:
pusha
mov edx , VIDEO_MEMORY ; Set edx to the start of vid mem.
</code></pre>
<pre><code>print_string_pm_loop:
mov al, [ebx] ; Store the char at EBX in AL
mov ah, WHITE_ON_BLACK ; Store the attributes in AH
</code></pre>
<pre><code>cmp al, 0 ; if (al == 0), at end of string , so
je done ; jump to done
</code></pre>
<pre><code>mov [edx], ax ; Store char and attributes at current
; character cell.
add ebx , 1 ; Increment EBX to the next char in string.
add edx , 2 ; Move to next character cell in vid mem.
</code></pre>
<pre><code>jmp print_string_pm_loop ; loop around to print the next char.
</code></pre>
<pre><code>print_string_pm_done :
popa
ret ; Return from the function
</code></pre>
<p>Figure 4.1: A routine for printing a string directly to video memory (i.e.</p>
<p>without using BIOS).</p>
<p>The downside to our routine is that it always prints the string to the top-left of the<br>
screen, and so will overwrite previous messages rather than scrolling. We could spend<br>
time adding to the sophistication of this assembly routine, but let’s not make things too<br>
hard for ourselves, since after we master the switch to protected mode, we will soon be<br>
booting code written in a higher level language, where we can make much lighter work<br>
of these things.</p>
<h3 id="understanding-the-global-descriptor-table">4.2 Understanding the Global Descriptor Table</h3>
<p>It is important to understand the main point of this GDT, that is so fundamental to<br>
the operation of protected mode, before we delve into the details. Recall from Section<br>
XXX that the design rationale of segment-based addressing in the classical 16-bit real<br>
mode was to allow the programmer to access (albeit slightly, by today’s standards) more<br>
memory than a 16-bit offset would allow. As an example of this, suppose that the<br>
programmer wanted to store the value ofaxat the address0x4fe56. Without segment-</p>
<p>CHAPTER 4. ENTERING 32-BIT PROTECTED MODE 33</p>
<p>based addressing, the best the programmer could do is this:</p>
<pre><code>mov [0xffff], ax
</code></pre>
<p>which falls way short of the intended address. Whereby, using a segment register, the<br>
task could be achieved as follows:</p>
<pre><code>mov bx, 0x4000
mov es, bx
mov [es:0xfe56], ax
</code></pre>
<p>Although the general idea of segmenting memory and using offsets to reach into those<br>
segments has remained the same, the way that it is implented in protected mode has<br>
completely changed, primarily to afford more flexibility. Once the CPU has been switched<br>
into 32-bit protected mode, the process by which it translates logical addresses (i.e.<br>
the combination of a segment register and an offset) to physical address is completely<br>
different: rather than multiply the value of a segment register by 16 and then add to it<br>
the offset, a segment register becomes an index to a particularsegment descriptor(SD)<br>
in the GDT.<br>
A segment descriptor is an 8-byte structure that defines the following properties of<br>
a protected-mode segment:</p>
<ul>
<li>Base address (32 bits), which defines where the segment begins in physical memory</li>
<li>Segment Limit (20 bits), which defines the size of the segment</li>
<li>Various flags, which affect how the CPU interprets the segment, such as the<br>
privilige level of code that runs within it or whether it is read- or write-only.<br>
Figure 4.2 shows the actual structure of the segment descriptor. Notice how, just<br>
to add to the confusion, the structure fragments the base address and segment limit<br>
throughout the structure, so, for example, the lower 16 bits of the segment limit are in<br>
the first two bytes of the structure but the higher 4-bits are at the start of the seventh<br>
byte of the structure. Perhaps this was done as some kind of joke, or more likley it has<br>
historic roots or was influenced by the CPU’s hardware design.<br>
We will not concern ourselves with details of all of the possible configurations of<br>
segment descriptors, a full explanation of which is given in Intel’s Developer Manual [?],<br>
but we will learn what we have to in order to get our code running in 32-bit protected<br>
mode.<br>
The simplest workable configuration of segment registers is described by Intel as the<br>
basic flat model, whereby two overlapping segments are defined that cover the full 4 GB<br>
of addressable memory, one forcodeand the other fordata. The fact that in this model<br>
these two segments overlap means that there is no attempt to protect one segment from<br>
the other, nor is there any attempt to use the paging features for virtual memory. It<br>
pays to keep things simple early on, especially since later we may alter the segment<br>
descriptors more easily once we have booted into a higher-level language.<br>
In addition to thecodeanddatasegments, the CPU requires that the first entry<br>
in the GDT purposely be an invalidnull descriptor(i.e. a structure of 8 zero bytes).<br>
The null descriptor is a simple mechanism to catch mistakes where we forget to set a<br>
particular segment register before accessing an address, which is easily done if we had<br>
some segment registers set to0x0and forgot to update them to the appropriate segment<br>
descriptors after switching to protected mode. If an addressing attempt is made with the<br>
null descriptor, then the CPU will raise an exception, which essentially is an interrupt —</li>
</ul>
<p>CHAPTER 4. ENTERING 32-BIT PROTECTED MODE 34</p>
<p>and which, although not too disimilar as a concept, is not to be confused with exceptions<br>
in higher level languages such as Java.</p>
<p>Figure 4.2: Segment descriptor structure.</p>
<pre><code>Ourcodesegment will have the following configuration:
</code></pre>
<ul>
<li>Base: 0x0</li>
<li>Limit: 0xfffff</li>
<li>Present: 1, since segment is present in memory - used for virtual memory</li>
<li>Privilige: 0, ring 0 is the highest privilige</li>
<li>Descriptor type: 1 for code or data segment, 0 is used for traps</li>
<li>Type:
<ul>
<li>Code: 1 for code, since this is a code segment</li>
<li>Conforming: 0, by not corming it means code in a segment with a lower<br>
privilege may not call code in this segment - this a key to memory protection</li>
<li>Readable: 1, 1 if readible, 0 if execute-only. Readible allows us to read<br>
constants defined in the code.</li>
<li>Accessed: 0 This is often used for debugging and virtual memory techniques,<br>
since the CPU sets the bit when it accesses the segment</li>
</ul>
</li>
<li>Other flags</li>
</ul>
<p>CHAPTER 4. ENTERING 32-BIT PROTECTED MODE 35</p>
<ul>
<li>Granularity: 1, if set, this multiplies our limit by 4 K (i.e. 16<em>16</em>16), so our<br>
0xfffff would become 0xfffff000 (i.e. shift 3 hex digits to the left), allowing<br>
our segment to span 4 Gb of memory</li>
<li>32-bit default: 1, since our segment will hold 32-bit code, otherwise we’d use<br>
0 for 16-bit code. This actually sets the default data unit size for operations<br>
(e.g. push 0x4 would expand to a 32-bit number ,etc.)</li>
<li>64-bit code segment: 0, unused on 32-bit processor</li>
<li>AVL: 0, We can set this for our own uses (e.g. debugging) but we will not<br>
use it</li>
</ul>
<p>Since we are using a simple flat model, with two overlapping code and data segments,<br>
thedatasegment will be identical but for the type flags:</p>
<ul>
<li>Code: 0 for data</li>
<li>Expand down: 0. This allows the segment to expand down - TODO<br>
explain this</li>
<li>Writable: 1. This allows the data segment to be written to, otherwise<br>
it would be read only</li>
<li>Accessed: 0 This is often used for debugging and virtual memory<br>
techniques, since the CPU sets the bit when it accesses the segment<br>
Now that we have seen an actual configuration of two segments, exploring most of<br>
the possible segment descriptor settings, it should be clearer how protected mode offers<br>
much more flexibilty in the partioning of memory than real mode.</li>
</ul>
<h3 id="defining-the-gdt-in-assembly">4.3 Defining the GDT in Assembly</h3>
<p>Now that we understand what segment descriptors to include in our GDT for the basic<br>
flat model, let us look at how we might actually represent the GDT in assembly, a task<br>
that requires more patience than anything else. Whilst you’re experiencing the shear<br>
tediousness of this, keep in mind the significance of it: what we do here will allow us<br>
soon to boot our operating system kernel, which we will write in a higher level language,<br>
then — for want of a better quote — our small steps will turn into giant leaps.<br>
We have already seen examples of how to define data within our assembly code,<br>
using thedb,dw, andddassembly directives, and these are exactly what we must use to<br>
put in place the appropriate bytes in the segment descriptor entries of our GDT.<br>
Actually, for the simple reason that the CPU needs to know how long our GDT is,<br>
we don’t actually directly give the CPU the start address of our GDT but instead give it<br>
the address of a much simpler structure called the GDT descriptor (i.e. something that<br>
describes the GDT). The GDT is a 6-byte structure containing:</p>
<ul>
<li>GDT size (16 bits)</li>
<li>GDT address (32 bits)<br>
Note, when working in such a low-level language with complex data structures like<br>
these, we cannot addenoughcomments. The following code defines our GDT and the<br>
GDT descriptor; in the code, notice how we usedb,dw, etc. to fill out parts of the</li>
</ul>
<p>CHAPTER 4. ENTERING 32-BIT PROTECTED MODE 36</p>
<p>structure and how the flags are more conveniently defined using literal binary numbers,<br>
that are suffixed withb:</p>
<pre><code>; GDT
gdt_start:
</code></pre>
<pre><code>gdt_null: ; the mandatory null descriptor
dd 0x0 ; ’dd’ means define double word (i.e. 4 bytes)
dd 0x0
</code></pre>
<pre><code>gdt_code: ; the code segment descriptor
; base=0x0, limit=0xfffff ,
; 1st flags: (present )1 (privilege )00 (descriptor type)1 -&gt; 1001b
; type flags: (code)1 (conforming )0 (readable )1 (accessed )0 -&gt; 1010b
; 2nd flags: (granularity )1 (32-bit default )1 (64-bit seg)0 (AVL)0 -&gt; 1100b
dw 0xffff ; Limit (bits 0-15)
dw 0x0 ; Base (bits 0-15)
db 0x0 ; Base (bits 16 -23)
db 10011010b ; 1st flags , type flags
db 11001111b ; 2nd flags , Limit (bits 16-19)
db 0x0 ; Base (bits 24 -31)
</code></pre>
<pre><code>gdt_data: ;the data segment descriptor
; Same as code segment except for the type flags:
; type flags: (code)0 (expand down)0 (writable )1 (accessed )0 -&gt; 0010b
dw 0xffff ; Limit (bits 0-15)
dw 0x0 ; Base (bits 0-15)
db 0x0 ; Base (bits 16 -23)
db 10010010b ; 1st flags , type flags
db 11001111b ; 2nd flags , Limit (bits 16-19)
db 0x0 ; Base (bits 24 -31)
</code></pre>
<pre><code>gdt_end: ; The reason for putting a label at the end of the
; GDT is so we can have the assembler calculate
; the size of the GDT for the GDT decriptor (below)
</code></pre>
<pre><code>; GDT descriptior
gdt_descriptor:
dw gdt_end - gdt_start - 1 ; Size of our GDT , always less one
; of the true size
dd gdt_start ; Start address of our GDT
</code></pre>
<pre><code>; Define some handy constants for the GDT segment descriptor offsets , which
; are what segment registers must contain when in protected mode. For example ,
; when we set DS = 0x10 in PM , the CPU knows that we mean it to use the
; segment described at offset 0x10 (i.e. 16 bytes) in our GDT , which in our
; case is the DATA segment (0x0 -&gt; NULL; 0x08 -&gt; CODE; 0x10 -&gt; DATA)
CODE_SEG equ gdt_code - gdt_start
DATA_SEG equ gdt_data - gdt_start
</code></pre>
<h3 id="making-the-switch">4.4 Making the Switch</h3>
<p>Once both the GDT and the GDT descriptor have been prepared within our boot sector,<br>
we are ready to instruct the CPU to switch from 16-bit real mode into 32-bit protected<br>
mode.</p>
<p>CHAPTER 4. ENTERING 32-BIT PROTECTED MODE 37</p>
<p>Like I said before, the actual switchover is fairly straight forward to code, but it is<br>
important to understand the significance of the steps involved.<br>
The first thing we have to do is disable interrupts using thecli(clear interrupt)<br>
instruction, which means the CPU will simply ignore any future interrupts that may<br>
happen, at least until interrupts are later enabled. This is very important, because, like<br>
segment based addressing, interrupt handling is implemtented completely differently in<br>
protected mode than in real mode, making the current IVT that BIOS set up at the start<br>
of memory completely meaningless; and even if the CPU could map interrupt signals to<br>
their correct BIOS routines (e.g. when the user pressed a key, store its value in a buffer),<br>
the BIOS routines would be executing 16-bit code, which will have no concept of the<br>
32-bit segments we defined in our GDT and so will ulimately crash the CPU by having<br>
segment register values that assume the 16-bit real mode segmenting scheme.<br>
The next step is to tell the CPU about the GDT that we just prepared — with great<br>
pain. We use a single instruction to do this, to which we pass the GDT descriptor:</p>
<pre><code>lgdt [gdt_descriptor]
</code></pre>
<p>Now that all is in-place, we make the actual switch over, by setting the first bit of a<br>
special CPU control register,cr0. Now, we cannot set that bit directly on the register,<br>
so we must load it into a general purpose register, set the bit, then store it back into<br>
cr0. Similarly to how we used theandinstruction in Section XXX to exclude bits from<br>
a value, we can use theorinstruction to include certain bits into a value (i.e. without<br>
disturbing any other bits that, for some important reason, may have been set already in<br>
the control register) [?].</p>
<pre><code>mov eax , cr0 ; To make the switch to protected mode , we set
or eax , 0x1 ; the first bit of CR0 , a control register
mov cr0 , eax ; Update the control register
</code></pre>
<p>Aftercr0has been updated, the CPU is in 32-bit protected mode [?].<br>
That last statement is not entirely true, since modern processors use a technique<br>
calledpipelining, that allows them to process different stages of an instruction’s execution<br>
in parallel (and I am talking about single CPUs as opposed to parallel CPUs), and<br>
therefore in less time. For example, each instruction might befetchedfrom memory,<br>
decodedinto microcode instructions,executed, then perhaps the result isstoredback to<br>
memory; and since these stages are semi-independent, they could all be done within the<br>
same CPU cycle but within different circuitry (e.g. the previous instruction could be<br>
decodedwhilst the next isfetched) [?].<br>
We do not normally need to worry about CPU internals such as pipelining when<br>
programming the CPU, but switching CPU modes is a special case, since there is a risk<br>
that the CPU may process some stages of an instruction’s execution in the wrong mode.<br>
So what we need to do, immediately after instructing the CPU to switch mode, is to<br>
force the CPU to finish any jobs in its pipeline, so that we can be confident that all<br>
future instructions will be executed in the correct mode.<br>
Now, pipelining works very well when the CPU knows about the next few instructions<br>
that will be coming over the horizon, since it can pre-fetch them, but it doesn’t like<br>
instructions such asjmporcall, because until those instructions have been executed<br>
fully the CPU can have no idea about the instructions that will follow them, especially if<br>
we use afarjump or call, which means that we jump to another segment. So immediately<br>
after instructing the CPU to switch mode, we can issue a far jump, which will force the</p>
<p>CHAPTER 4. ENTERING 32-BIT PROTECTED MODE 38</p>
<p>CPU to flush the pipeline (i.e. complete all of instructions currently in different stages<br>
of the pipeline).<br>
To issue a far jump, as opposed to a near (i.e. standard) jump, we additionally<br>
provide the target segment, as follows:</p>
<pre><code>jmp &lt;segment &gt;:&lt;address offset &gt;
</code></pre>
<p>For this jump, we need to think carefully about where we wish to land. Suppose we set up<br>
a label in our code such asstartprotectedmodethat marks the beginning of our 32-bit<br>
code. As we have just discussed, anearjump, such asjmp startprotectedmodemay<br>
not be sufficient to flush the pipeline, and, besides we are now in some strange limbo,<br>
since our current code segment (i.e. cs) will not be valid in protected mode. So, we<br>
must update ourcsregister to the offset of the code segment descriptor of our GDT.<br>
Since the segment descriptiors are each 8 bytes long, and since our code descriptor was<br>
the second descriptor in our GDT (the null descriptor was the first), its offset will be<br>
0x8, and so this value is what we must now set our code segment register to. Note that,<br>
by the very definition of a far jump, it will automatically cause the CPU to update our<br>
csregister to the target segment. Making handy use of labels, we got our assembler to<br>
calculate these segment descriptor offsets and store them as the constantsCODESEGand<br>
DATASEG, so now we arrive at out jump instruction:</p>
<pre><code>jmp CODE_SEG:start_protected_mode
</code></pre>
<pre><code>[bits 32]
</code></pre>
<pre><code>start_protected_mode:
... ; By now we are assuredly in 32-bit protected mode.
...
</code></pre>
<p>Note that, in fact, we don’t need to jump very far at all in terms of the physical distance<br>
between the where we jumped from and where we landed, but the importance was in<br>
how we jump.<br>
Note also that we need to use the[bits 32]directive to tell our assembler that,<br>
from that point onwards, it should encode in 32-bit mode instructions. Note, though,<br>
that this does not mean we cannot use 32-bit instructions in 16-bit real mode, just that<br>
the assembler must encode those instructions slightly differently than in 32-bit protected<br>
mode [?]. Indeed, when switching to protected mode, we made use of the 32-bit register<br>
eaxto set the control bit.<br>
Now we are in 32-bit protected mode. A good thing to do once we have entered<br>
32-bit mode proper is to update all of the other segment registers so they now point to<br>
our 32-bit data segment (rather than the now-invalid real mode segments) and update<br>
the position of the stack.<br>
We can combine the whole process into a re-usable routine, as in Figure XXX.</p>
<pre><code>[bits 16]
; Switch to protected mode
switch_to_pm:
cli ; We must switch of interrupts until we have
; set -up the protected mode interrupt vector
; otherwise interrupts will run riot.
</code></pre>
<p>CHAPTER 4. ENTERING 32-BIT PROTECTED MODE 39</p>
<pre><code>lgdt [gdt_descriptor] ; Load our global descriptor table , which defines
; the protected mode segments (e.g. for code and data)
</code></pre>
<pre><code>mov eax , cr0 ; To make the switch to protected mode , we set
or eax , 0x1 ; the first bit of CR0 , a control register
mov cr0 , eax
jmp CODE_SEG:init_pm ; Make a far jump (i.e. to a new segment) to our 32-bit
; code. This also forces the CPU to flush its cache of
; pre -fetched and real -mode decoded instructions , which can
; cause problems.
</code></pre>
<pre><code>[bits 32]
; Initialise registers and the stack once in PM.
init_pm:
</code></pre>
<pre><code>mov ax, DATA_SEG ; Now in PM, our old segments are meaningless ,
mov ds, ax ; so we point our segment registers to the
mov ss, ax ; data selector we defined in our GDT
mov es, ax
mov fs, ax
mov gs, ax
</code></pre>
<pre><code>mov ebp , 0x90000 ; Update our stack position so it is right
mov esp , ebp ; at the top of the free space.
</code></pre>
<pre><code>call BEGIN_PM ; Finally , call some well -known label
</code></pre>
<h3 id="putting-it-all-together-3">4.5 Putting it all Together</h3>
<p>Finally, we can include all of our routines into a boot sector that demonstrates the switch<br>
from 16-bit real mode into 32-bit protected mode.</p>
<pre><code>; A boot sector that enters 32-bit protected mode.
[org 0x7c00]
</code></pre>
<pre><code>mov bp, 0x9000 ; Set the stack.
mov sp, bp
</code></pre>
<pre><code>mov bx, MSG_REAL_MODE
call print_string
</code></pre>
<pre><code>call switch_to_pm ; Note that we never return from here.
</code></pre>
<pre><code>jmp $
</code></pre>
<pre><code>%include "../print/print_string.asm"
%include "gdt.asm"
%include "print_string_pm.asm"
%include "switch_to_pm.asm"
</code></pre>
<pre><code>[bits 32]
</code></pre>
<p>CHAPTER 4. ENTERING 32-BIT PROTECTED MODE 40</p>
<pre><code>; This is where we arrive after switching to and initialising protected mode.
BEGIN_PM:
</code></pre>
<pre><code>mov ebx , MSG_PROT_MODE
call print_string_pm ; Use our 32-bit print routine.
</code></pre>
<pre><code>jmp $ ; Hang.
</code></pre>
<pre><code>; Global variables
MSG_REAL_MODE db "Started in 16-bit Real Mode", 0
MSG_PROT_MODE db "Successfully landed in 32-bit Protected Mode", 0
</code></pre>
<pre><code>; Bootsector padding
times 510-($-$$) db 0
dw 0xaa55
</code></pre>
<h1 id="chapter-5">Chapter 5</h1>
<h1 id="writing-building-and-loading">Writing, Building, and Loading</h1>
<h1 id="your-kernel">Your Kernel</h1>
<p>So far, we have learnt a lot about how the computer really works, by communicating<br>
with it in the low-level assembly language, but we’ve also seen how it can be very slow<br>
to progress in such a language: we need to think very carefully even about the simplest<br>
of control structures (e.g.if ()else), and we<br>
have to worry about how best to make use of the limited number of registers, and juggle<br>
with the stack. Another drawback of us continuing in assembly language is that it is<br>
closely tied to the specific CPU architecture, and so it would be harder for us to port<br>
our operating system to another CPU architecture (e.g. ARM, RISC, PowerPC).<br>
Luckily, other programmers also got fed up of writing in assembly, so decided to write<br>
higher-level language compilers (e.g. FORTRAN, C, Pascal, BASIC, etc.), that would<br>
transform more intuitive code into assembly language. The idea of these compilers is to<br>
map higher level constructs, such as control structures and function calls onto assembly<br>
template code, and so the downside — and there usually always is a downside — is<br>
that the generic templates may not always be optimal for specific functionality. Without<br>
further ado, let us look at how C code is transformed into assembly to demystify the role<br>
of the compiler.</p>
<h3 id="understanding-c-compilation">5.1 Understanding C Compilation</h3>
<p>Let’s write some small code snippets in C and see what sort of assembly code they<br>
generate. This is a great way of learning about how C works.</p>
<h4 id="generating-raw-machine-code">5.1.1 Generating Raw Machine Code</h4>
<pre><code>// Define an empty function that returns an integer
</code></pre>
<p>41</p>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 42</p>
<pre><code>int my_function () {
return 0xbaba;
}
</code></pre>
<p>Save the code in Figure XXXX into a file calledbasic.c, and compile it as follows:</p>
<p>$gcc -ffreestanding -c basic.c -o basic.o<br>
This will produce anobject file, which, being completely unrelated, is not to be con-<br>
fused with the concept of object-oriented programming. Rather than compiling directly<br>
into machine code, the compiler outputsannotatedmachine code, where meta informa-<br>
tion, such as textual labels, that are redundant for execution, remain present to enable<br>
more flexibilty in how the code is eventually put together. One big advantage of this<br>
intermediary format is that the code may be easily relocated into a larger binary file<br>
when linked in with routines from other routines in other libraries, since code in the<br>
object file uses relative rather than absolute internel memory references. We can get a<br>
good view of an object file’s contents with the following command:</p>
<p>$objdump -d basic.o<br>
The output of this command will give something like that in Figure XXX. Note that<br>
we can see some assembly instructions and some additional details about the code. Note<br>
that the syntax of the assembly is very slightly different to that used by nasm, so simply<br>
ignore this part, since we will soon see it in a more familiar format.</p>
<pre><code>basic.o: file format elf32 -i386
</code></pre>
<pre><code>Disassembly of section .text:
</code></pre>
<pre><code>00000000 &lt;my_function &gt;:
0: 55 push %ebp
1: 89 e5 mov %esp ,%ebp
3: b8 ba ba 00 00 mov $0xbaba ,%eax
8: 5d pop %ebp
9: c3 ret
</code></pre>
<p>In order to create the actual executable code (i.e. that will run on our CPU),<br>
we have to use alinker, whose role is to link together all of the routines described in<br>
the input object files into one executable binary file, effectively stitching them together<br>
and converting those relative addresses into absolute addresses within the aggregated<br>
machine code, for example: callwill becomecall 0x12345,<br>
where0x12345is the offset within the output file that the linker decided to place the<br>
code for the routine denoted byfunctionXlabel.<br>
In our case, though, we do not want to link with any routines from any other object<br>
files — we will look at this shortly — but nevertheless the linker will convert our anno-<br>
tated machine code file into a raw machine code file. To output raw machine code into<br>
a filebasic.bin, we can use the following command:</p>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 43</p>
<p>$ld -o basic.bin -Ttext 0x0 --oformat binary basic.o<br>
Note that, like the compiler, the linker can output executable files in various for-<br>
mats, some of which may retain meta data from the input object files. This is useful<br>
for executables that are hosted by an operating system, such as the majory of programs<br>
we will write on a platform such as Linux or Windows, since meta data can be retained<br>
to describe how those applications are to be loaded into memory; and for debugging<br>
purposes, for example: the information that a process crashed at instruction address<br>
0x12345678is far less useful to a programmer than information presented using redun-<br>
dant, non-executable meta-data that a process crashed in functionmyfunction, file<br>
basic.c, on line 3.<br>
Anyhow, since we are interested in writing an operating system, it would be no good<br>
trying to run machine code intermingled with meta data on our CPU, since unaware the<br>
CPU will execute every byte as machine code. This is why we specify an output format<br>
of (raw)binary.<br>
The other option we used was-Ttext 0x0, which works in the same way as theorg<br>
directive we used in our earlier assembly routines, by allowing us to tell the compiler<br>
to offset label addresses in our code (e.g. for any data we specify in the code, such as<br>
strings like‘‘Hello, World’’) to their absolute memory addresses when later loaded<br>
to a specific origin in memory. For now this is not important, but when we come to load<br>
kernel code into memory, it is important that we set this to the address we plan to load<br>
to.<br>
Now we have successfully compiled the C code into a raw machine code file, that<br>
we could (once we have figured out how to load it) run on our CPU, so let’s see what<br>
it looks like. Luckily, since assembly maps very closely to machine code instructions, if<br>
you are ever given a file containing only machine code, you can easily disassemble it to<br>
view it in assembly. Ah, yes; this is another benefit of understanding a little of assembly,<br>
because you can potentially reverse-engineer any software that lands on you lap minus<br>
the original source code, even more successfully if the developer left in some meta data<br>
for you — which they nearly always do. The only problem with disassmbling machine<br>
code is that some of those bytes may have been reserved as data but will show up as<br>
assembly instructions, though in our simple C program we didn’t declare any data. To<br>
see what machine code the compiler actually generated from our C source code, run the<br>
following command:</p>
<p>$ndisasm -b 32 basic.bin &gt; basic.dis<br>
The-b 32simply tells the disassembler to decode to 32-bit assembly instructions,<br>
which is what our compiler generates. Figure XXX shows the assembly code generated<br>
by gcc for our simple C program.</p>
<pre><code>00000000 55 push ebp
00000001 89E5 mov ebp ,esp
00000003 B8BABA0000 mov eax ,0xbaba
00000008 5D pop ebp
00000009 C3 ret
</code></pre>
<p>So here it is: gcc generated some assembly code not too disimilar to that which we<br>
have been writing ourselves already. The three columns output from the disassembler,</p>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 44</p>
<p>from left to right, show the file offsets of the instructions, the machine code, and the<br>
equivalent assembly instructions. Although our function does a very simple thing, there<br>
is some addtional code in there that seems to be manipulating the stack’s base and top<br>
registers,ebpandesp. C makes heavy use of the stack for storing variables that are<br>
local to a function (i.e. variables that are no-longer needed when the function returns),<br>
so upon entering a function, the stack’s base pointer (ebp) is increased to the current<br>
top of the stack (mov ebp, esp), effectively creating a local, initially empty stack above<br>
the stack of the function that called our function. This process is often referred to as<br>
the function setting up itsstack frame, in which it will allocate any local variables.<br>
However, if prior to returning from our function we failed to restore the stack frame to<br>
that originally set up by our caller, the calling function would get in a real mess when<br>
trying to access its local variables; so before updating the base pointer for our stack<br>
frame, we must store it, and there is no better place to store it than the top of the stack<br>
(push ebp).<br>
After preparing our stack frame, which, sadly, doesn’t actually get used in our simple<br>
function, we see how the compiler handles the linereturn 0xbaba;: the value0xbabais<br>
stored in the 32-bit registereax, which is where the calling function (if there were one)<br>
would expect to find the returned value, similarly to how we had our own convention of<br>
using certain registers to pass arguments to our earlier assembly routines, for example:<br>
ourprintstringroutine expected to find the address of the string to be printed in the<br>
registerbx.<br>
Finally, before issuingretto return to the caller, the function pops the original stack<br>
base pointer off the stack (pop ebp), so the calling function will be unaware that its own<br>
stack frame was ever changed by the called function. Note that we didn’t actuall change<br>
the top of the stack (esp), since in this case our stack frame was used to store nothing,<br>
so the untouchedespregister did not require restoring.<br>
Now we have a good idea about how C code translates into assembly, so let’s prod<br>
the compiler a little further until we have sufficient understanding to write a simple<br>
kernel in C.<br>
[?]</p>
<h4 id="local-variables">5.1.2 Local Variables</h4>
<p>Now write the code in Figure XXX into a file calledlocalvar.cand compile, link, and<br>
disassemble it as before.</p>
<pre><code>// Declare a local variable.
int my_function () {
int my_var = 0xbaba;
return my_var;
}
</code></pre>
<pre><code>Now the compiler generates the assembly code in Figure XXX.
</code></pre>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 45</p>
<pre><code>00000000 55 push ebp
00000001 89E5 mov ebp ,esp
00000003 83EC10 sub esp ,byte +0x10
00000006 C745FCBABA0000 mov dword [ebp -0x4],0xbaba
0000000D 8B45FC mov eax ,[ebp -0x4]
00000010 C9 leave
00000011 C3 ret
</code></pre>
<p>The only difference now is that we actually allocate a local variable,myvar, but<br>
this provokes an interesting response from the compiler. As before, the stack frame is<br>
established, but then we seesub esp, byte +0x10, which is subtracting 16 (0x10) bytes<br>
from the top of the stack. Firstly, we have to (constantly) remind ourselves that the stack<br>
grows downwards in terms of memory addresses, so in simpler terms this instructions<br>
means, ’allocate another 16 bytes on the top of stack’. We are storing anint, which is<br>
a 4-byte (32-bit) data type, so why have 16 bytes been allocated on the stack for this<br>
variable, and why not usepush, which allocates new stack space automatically? The<br>
reason the compiler manipulates the stack in this way is one of optimsation, since CPUs<br>
often operate less efficiently on a datatype that is not aligned on memory boundaries that<br>
are multiples of the datatype’s size [?]. Since C would like all variables to be properly<br>
aligned, it uses the maximum datatype width (i.e. 16 bytes) for all stack elements, at<br>
the cost of wasting some memory.<br>
The next instruction,mov dword [ebp-0x4],0xbaba, actually stores our variable’s<br>
value in the newly allocated space on the stack, but without usingpush, for the previously<br>
given reason of stack efficiency (i.e. the size of the datatype stored is less than the stack<br>
space reserved). We understand the general use of themovinstruction, but two things<br>
that deserve some explanation here are the use ofdwordand[ebp-0x4]:</p>
<ul>
<li>dwordstates explicitly that we are storing adouble word(i.e. 4 bytes) on the<br>
stack, which is the size of ourintdatatype. So the actual bytes stored would<br>
be0x0000baba, but without being explicit could easily be0xbaba(i.e. 2 bytes)<br>
or0x000000000000baba(i.e. 8 bytes), which, although the same value, have<br>
different ranges.</li>
<li>[ebp-0x4]is an example of a modern CPU shortcut calledeffective address com-<br>
putation[?], which is more impressive that the assembly code seems to reflect.<br>
This part of the instruction references an address that is calculatedon-the-flyby<br>
the CPU, based on the current address of registerebp. At a glance, we might<br>
think our assembler is manipulating a constant value, as it would if we wrote<br>
something like thismov ax, 0x5000 + 0x20, where our assembler would simply<br>
pre-process this intomov ax, 0x5020. But only once the code is run would the<br>
value of any register be known, so this definitely is not pre-processing; it forms a<br>
part of the CPU instruction. With this form of addressing the CPU is allowing<br>
us to do more per instruction cycle, and is good example of how CPU hardware<br>
has adapted to better suit programmers. We could write the equivalent, without<br>
such address manipulation, less efficiently in the following three lines of code:</li>
</ul>
<pre><code>mov eax , ebp ; EAX = EBP
sub eax , 0x4 ; EAX = EAX - 0x4
mov [eax], 0xbaba ; store 0xbaba at address EAX
</code></pre>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 46</p>
<p>So the value0xbabais stored directly to the appropriate position of the stack, such that<br>
it will occupy the first 4 bytes above (though physically below, since the stack grows<br>
downwards) the base pointer.<br>
Now, being a computer program, our compiler can distinguish different numbers as<br>
easily as we can distinguish different variable names, so what we think of as the variable<br>
myvar, the compiler will think of as the addressebp-0x4(i.e. the first 4 bytes of the<br>
stack). We see this in the next instruction,mov eax,[ebp-0x4], which basically means,<br>
’store the contents ofmyvarineax’, again using efficiently address computation; and<br>
we know from the previous function thateaxis used to return a variable to the caller of<br>
our function.<br>
Now, before theretinstruction, we see something new: theleave instruction.<br>
Actually, theleaveinstruction is an alternative to the following steps, that restore the<br>
original stack of the caller, recipricol of the first two instruction of the function:</p>
<pre><code>mov esp , ebp ; Put the stack back to as we found it.
pop ebp
</code></pre>
<p>Though only a single instruction, it is not always the case thatleaveis more efficient<br>
than the seperate instructions [?]. Since our compiler chose to use this instruction, we<br>
will leave that particular discussion to other people.</p>
<h4 id="calling-functions-1">5.1.3 Calling Functions</h4>
<p>Not let’s look at the C code in Figure XXX, which has two functions, where one function,<br>
callerfunction, calls the other,calleefunction, passing it an integer argument.<br>
The called function simply returns the argument it was passed.</p>
<pre><code>void caller_function () {
callee_function (0 xdede);
}
</code></pre>
<pre><code>int callee_function(int my_arg) {
return my_arg;
}
</code></pre>
<p>If we compile and disassemble the C code, we will get something similar to that in<br>
Figure XXX.</p>
<pre><code>00000000 55 push ebp
00000001 89E5 mov ebp ,esp
00000003 83EC08 sub esp ,byte +0x8
00000006 C70424DEDE0000 mov dword [esp],0xdede
0000000D E802000000 call dword 0x14
00000012 C9 leave
00000013 C3 ret
00000014 55 push ebp
00000015 89E5 mov ebp ,esp
00000017 8B4508 mov eax ,[ebp+0x8]
</code></pre>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 47</p>
<pre><code>0000001A 5D pop ebp
0000001B C3 ret
</code></pre>
<p>Firstly, notice how we can differntiate between assembly code of the two functions<br>
by looking for the tell-taleretinstruction that always appears as the last instruction<br>
of a function. Next, notice how the upper function uses the assembly instructioncall,<br>
which we know is used to jump to another routine from which usually we expect to<br>
return. This must be ourcallerfunction, that is callingcalleefunctionat off-<br>
set0x14of the machine code. The most interesting lines here are those immediately<br>
before the call, since they are somehow ensuring that the argumentmyargis passed<br>
tocalleefunction. After establishing its stack frame, as we have seen to be com-<br>
mon to all functions,callerfunctionallocates 8 bytes on the top of the stack (sub<br>
esp,byte +0x8), then stores our passed value,0xdede, into that stack space (mov dword<br>
[esp],0xdede).<br>
So let’s see howcalleefunctionaccesses that argument. From offset0x14, we<br>
see thatcalleefunctionestablishes its stack frame as usual, but then look at what it<br>
stores in theeaxregister, a register that we know from our earlier analysis is used to<br>
hold a function’s return value: it stores the contents of address[ebp + 0x8]. Here we<br>
have to remind ourselves again of that confusing fact that the stack grows downwards<br>
in memory, so in terms of logically-more-sensible upward growing stack,ebp + 0x8is<br>
8 bytesbelowour stack’s base, so we are actually reaching into the stack frame of the<br>
function that called us to get the argument’s value. This is what we’d expect, of course,<br>
because the caller put that value onto the top of their stack, then we put our stack base<br>
at the top of their stack to establish our stack frame.<br>
It is very useful to know the calling convention used by any high-level language com-<br>
piler when interfacing its code in assembly. For example, the default calling convention<br>
of C is to push arguments onto the stack in reverse order, so the first argument is on the<br>
top of the stack. To mix up the order of arguments would certainly cause the program<br>
to perform incorrectly, and likely crash.</p>
<h4 id="pointers-addresses-and-data">5.1.4 Pointers, Addresses, and Data</h4>
<p>When working in a high-level language we can easily find ourselves forgetting about the<br>
fact that variables are simply references to allocated memory addresses, where sufficient<br>
space has been reserved to accomodate their particular data type. This is because, in<br>
most cases when we are dealing with variables, we are really only interested in the values<br>
that they hold, rather than where they reside in memory. Consider the following snippet<br>
of C code:</p>
<pre><code>int a = 3;
int b = 4;
int total = a + b;
</code></pre>
<p>Now that we have more of an awareness about how the computer will actually perform<br>
these simple C instructions, we could make a well informed assumption that the instruc-<br>
tionint a = 3;will involve two main steps: firstly, at least 4 bytes (32 bits) will be<br>
reserved, perhaps on the stack, to hold the value; then, the value 3 will be stored at the<br>
reserved address. The same would be the case for the second line. And in the lineint</p>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 48</p>
<p>total = a + b;, some more space will be reserved for the variabletotal, and in it will<br>
be stored the addition of thecontents of addressespointed to by the labelsaandb.<br>
Now, suppose that we’d like to store a value at a specific address of memory; for<br>
example, like we have done in assembly, to write characters directly to the video memory<br>
at address0xb8000when BIOS was no longer available. How would we do that in C,<br>
when it seems that any value we wish to store must be in an address that has been<br>
determined by the compiler? Indeed, some high-level languages do not allow us to access<br>
memory in this way at all, which essentially is breaking the fluffy abstraction of the<br>
language. Luckily, C allows us to usepointer variables, that are datatypes used for<br>
storing addresses (rather than values), and which we candereferenceto read or write<br>
data to wherever they point.<br>
Now, technically, all pointer variables are the same datatype (e.g. a 32-bit memory<br>
address), but usually we plan to read and write specific datatypes from and to the address<br>
pointed to by a pointer, so we tell the compiler that, say,thisis a pointer to acharand<br>
thatis a pointer to anint. This is really a convenience, so that we do not always have<br>
to tell the compiler how many bytes it should read and write from the address held in a<br>
certain pointer. The syntax for defining and using pointers is shown in Figure XXX.</p>
<pre><code>// Here , the star following the type means that this is not a variable to hold
// a char (i.e. a single byte) but a pointer to the ADDRESS of a char ,
// which , being an address , will actually require the allocation of at least
// 32 bits.
char* video_address = 0xb8000;
</code></pre>
<pre><code>// If we’d like to store a character at the address pointed to, we make the
// assignment with a star -prefixed pointer variable. This is known as
// dereferencing a pointer , because we are not changing the address held by
// the pointer variable but the contents of that address.
*video_address = ’X’;
</code></pre>
<pre><code>// Just to emphasise the purpose of the star , an ommision of it, such as:
video_address = ’X’;
// would erroneously store the ASCII code of ’X’ in the pointer variable ,
// such that it may later be interpretted as an address.
</code></pre>
<p>In C code we often seechar*variables used for strings. Let’s think about why this<br>
is. If we’d like to store a singleintorchar, then we know that they are both fixed<br>
sized datatypes (i.e. we know how many bytes they will use), but a string is anarray<br>
of datatypes (usually ofchar), which may be of any length. So, since a single datatype<br>
cannot hold an entire string, only one element of it, we can use a pointer to achar, and<br>
set it to the memory address of the first character of the string. This is actually what<br>
we did in our assembly routines, such asprintstring, where we allocated a string<br>
of characters (e.g. ‘‘Hello, World’’) somewhere within our code, then, to print a<br>
particular string, we passed the first character’s address via thebxregister.<br>
Let’s look at an example of what the compiler does when we set up a string variable.<br>
In Figure XXX, we define a simple function that does nothing else other than allocate a<br>
string to a variable.</p>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 49</p>
<pre><code>void my_function () {
char* my_string = "Hello";
}
</code></pre>
<pre><code>As before, we can disassemble to give something like that in Figure XXX.
</code></pre>
<pre><code>00000000 55 push ebp
00000001 89E5 mov ebp ,esp
00000003 83EC10 sub esp ,byte +0x10
00000006 C745FA48656C6C mov dword [ebp -0x6],0x6c6c6548
0000000D 66 C745FE6F00 mov word [ebp -0x2],0x6f
00000013 C9 leave
00000014 C3 ret
</code></pre>
<p>Firstly, to get our bearings we look for theretinstruction, that marks the end of the<br>
function. We see that the first two instructions of the function set the stack frame up,<br>
as usual. The next instruction, which we have also seen before,sub esp,byte +0x10,<br>
allocates 16 bytes on the stack to store our local variable. Now, the next instruction,<br>
mov dword [ebp-0x4],0xf, should have a familiar form, since it stores a value in our<br>
variable; but why does it store the number0xf— we didn’t tell it to do that, did we?<br>
After storing this suspicious value, we see the function politley revert the stack to the<br>
callers stack frame (leave) then return (ret). But look, there are five more instructions<br>
after the end of the function! What do you think the instructiondec eaxis doing?<br>
Perhaps it decreases the value ofeaxby 1, but why? And what about the rest of the<br>
instructions?<br>
At times like this we need to do a sanity check, and remember that: the disasembler<br>
cannot distinguish between code and data; and somewhere in that code must be data<br>
for the string we defined. Now, we know that our function consists of the first half of<br>
the code, since these instructions made sense to us, and they ended withret. If we now<br>
assume that the rest of the code is in fact our data, then the suspicious value,0xf, that<br>
was stored in our variable makes sense, because it is the offset from the start of the code<br>
to where the data begins: our pointer variable is being set the the address of the data.<br>
To reassure our instincts, if we looked up in an ASCII table the character values of our<br>
string‘‘Hello’’, we would find them to be0x48,0x65,0x6c,0x6c, and0x6f. Now it<br>
is becoming clear, because if we look at the middle column of the disasembler output we<br>
see that these are the machine code bytes for those strange instructions that didn’t seem<br>
to make sense; we see also that the very last byte is0x0, which C adds automatically to<br>
the end of strings, so that, like in our assembly routineprintstring, during processing<br>
we can easily determine when we reach the end of the string.</p>
<h3 id="executing-our-kernel-code">5.2 Executing our Kernel Code</h3>
<p>Enough of the theory, let’s boot and execute the simplest of kernels written in C. This step<br>
will use all we have learnt so far, and will pave the way to faster progress in developing<br>
our operating system’s features.</p>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 50</p>
<pre><code>The involved steps are as follows:
</code></pre>
<ul>
<li>Write and compile the kernel code.</li>
<li>Write and assemble the boot sector code</li>
<li>Create a kernel image that includes not only our boot sector but our compiled<br>
kernel code</li>
<li>Load our kernel code into memory</li>
<li>Switch to 32-bit protected mode</li>
<li>Begin executing our kernel code</li>
</ul>
<h4 id="writing-our-kernel">5.2.1 Writing our Kernel</h4>
<p>This will not take long, since, for the moment, the main function of our kernel mearly<br>
is to let us know it has been successfully loaded and executed. We can elaborate on the<br>
kernel later, so it is important initially to keep things simple. Save the code in Figure<br>
XXX into a file calledkernel.c.</p>
<pre><code>void main() {
// Create a pointer to a char , and point it to the first text cell of
// video memory (i.e. the top -left of the screen)
char* video_memory = (char*) 0xb8000;
// At the address pointed to by video_memory , store the character ’X’
// (i.e. display ’X’ in the top -left of the screen ).
*video_memory = ’X’;
}
</code></pre>
<p>Compile this to raw binary as follows:<br>
$gcc -ffreestanding -c kernel.c -o kernel.o<br>
$ld -o kernel.bin -Ttext 0x1000 kernel.o --oformat binary<br>
Note that, now, we tell the linker that the origin of our code once we load it into<br>
memory will be0x1000, so it knows to offset local address references from this origin,<br>
just like we use[org 0x7c00]in our boot sector, because that is where BIOS loads and<br>
then begins to exectute it.</p>
<h4 id="creating-a-boot-sector-to-bootstrap-our-kernel">5.2.2 Creating a Boot Sector to Bootstrap our Kernel</h4>
<p>We are going to write a boot sector now, that must bootstrap (i.e. load and begin<br>
executing) our kernel from the disk. Since the kernel was compiled as 32-bit instructions,<br>
we are going to have to switch into 32-bit protected mode before executing the kernel<br>
code. We know that BIOS will load only our boot sector (i.e the first 512 bytes of the<br>
disk), and so not our kernel, when the computer boots, but in Section XXX we have seen<br>
how we can use the BIOS disk routines to have our boot sector load additional sectors<br>
from a disk, and we are vaguely aware that, after we switch into protected mode, the</p>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 51</p>
<p>lack of BIOS will make it hard for us to use the disk: we would have to write a floppy<br>
or hard disk driver ourselves!<br>
To simplfy the problem of which disk and from which sectors to load the kernel code,<br>
the boot sector and kernel of an operating system can be grafted together into akernel<br>
image, which can be written to the initial sectors of the boot disk, such that the boot<br>
sector code is always at the head of the kernel image. Once we have compiled the boot<br>
sector described in this section, we can create our kernel image with the following file<br>
concatenation command:</p>
<p>cat bootsect.bin kernel.bin &gt; os-image<br>
Figure XXX shows a boot sector that will bootstrap our kernel from a disk containing<br>
our kernel image,os-image.</p>
<pre><code>; A boot sector that boots a C kernel in 32-bit protected mode
[org 0x7c00]
KERNEL_OFFSET equ 0x1000 ; This is the memory offset to which we will load our kernel
</code></pre>
<pre><code>mov [BOOT_DRIVE], dl ; BIOS stores our boot drive in DL, so it’s
; best to remember this for later.
</code></pre>
<pre><code>mov bp, 0x9000 ; Set -up the stack.
mov sp, bp
mov bx, MSG_REAL_MODE ; Announce that we are starting
call print_string ; booting from 16-bit real mode
</code></pre>
<pre><code>call load_kernel ; Load our kernel
</code></pre>
<pre><code>call switch_to_pm ; Switch to protected mode , from which
; we will not return
</code></pre>
<pre><code>jmp $
</code></pre>
<pre><code>; Include our useful , hard -earned routines
%include "print/print_string.asm"
%include "disk/disk_load.asm"
%include "pm/gdt.asm"
%include "pm/print_string_pm.asm"
%include "pm/switch_to_pm.asm"
</code></pre>
<pre><code>[bits 16]
</code></pre>
<pre><code>; load_kernel
load_kernel:
mov bx, MSG_LOAD_KERNEL ; Print a message to say we are loading the kernel
call print_string
</code></pre>
<pre><code>mov bx, KERNEL_OFFSET ; Set -up parameters for our disk_load routine , so
mov dh, 15 ; that we load the first 15 sectors (excluding
mov dl, [BOOT_DRIVE] ; the boot sector) from the boot disk (i.e. our
call disk_load ; kernel code) to address KERNEL_OFFSET
</code></pre>
<pre><code>ret
</code></pre>
<pre><code>[bits 32]
; This is where we arrive after switching to and initialising protected mode.
</code></pre>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 52</p>
<pre><code>BEGIN_PM:
</code></pre>
<pre><code>mov ebx , MSG_PROT_MODE ; Use our 32-bit print routine to
call print_string_pm ; announce we are in protected mode
</code></pre>
<pre><code>call KERNEL_OFFSET ; Now jump to the address of our loaded
; kernel code , assume the brace position ,
; and cross your fingers. Here we go!
</code></pre>
<pre><code>jmp $ ; Hang.
</code></pre>
<pre><code>; Global variables
BOOT_DRIVE db 0
MSG_REAL_MODE db "Started in 16-bit Real Mode", 0
MSG_PROT_MODE db "Successfully landed in 32-bit Protected Mode", 0
MSG_LOAD_KERNEL db "Loading kernel into memory.", 0
</code></pre>
<pre><code>; Bootsector padding
times 510-($-$$) db 0
dw 0xaa55
</code></pre>
<p>Before running this command in Bochs, ensure that the Bochs configuration file has<br>
the boot disk set to your kernel image file, as in Figure XXX.</p>
<pre><code>floppya: 1_44=os-image , status=inserted
boot: a
</code></pre>
<p>One question you might be wondering is why we loaded as many as 15 segments<br>
(i.e. 512 * 15 bytes) from the boot disk, when our kernel image was much smaller than<br>
this; actually it was less than one sector in size, so to load 1 sector would have done<br>
the job. The reason is simply that it does not hurt to read those additional sectors<br>
from the disk, even if they have not been initialised with data, but it may hurt when<br>
trying to detect that we didn’t read enough sectors at this stage when we later add<br>
to, and therefore increase the memory footprint size of, our kernel code: the computer<br>
would hang without warning, perhaps halfway though a routine that was split across an<br>
unloaded sector boundary — an ugly bug.<br>
Congratulations if an ’X’ was displayed in the top-left corner of the screen, since<br>
though appearing pointless to the average computer user this signifies a hugh step from<br>
where we started: we have now boot-strapped into a higher-level language, and can start<br>
to worry less about assembly coding and concern ourselves more with how we would<br>
like to develop our operating system, and learning a little more about C, of course; but<br>
this is the best way to learn C: looking up to it as a higher level language rather than<br>
looking down upon it from the perspective of an even higher abstraction, such as Java<br>
or a scripting language (e.g. Python, PHP, etc.).</p>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 53</p>
<h4 id="finding-our-way-into-the-kernel">5.2.3 Finding Our Way into the Kernel</h4>
<p>It was definitely a good idea to start with a very simple kernel, but by doing so we<br>
overlooked a potential problem: when we boot the kernel, recklessly we jumped to, and<br>
therefore began execution from, the first instruction of the kernel code; but we saw in<br>
Section XXX how the C compiler can decide to place code and data whereever it chooses<br>
in the output file. Since our simple kernel had a single function, and based on our<br>
previous obsrevations of how the compiler generates machine code, we might assume<br>
that the first machine code instruction is the first instruction of kernel’s entry function,<br>
main, but suppose our kernel code look like that in Figure XXX.</p>
<pre><code>void some_function () {
}
</code></pre>
<pre><code>void main() {
char* video_memory = 0xb8000;
*video_memory = ’X’;
// Call some function
some_function ();
}
</code></pre>
<p>Now, the compiler will likely precede the instructions of the intended entry function<br>
mainby those ofsomefunction, and since our boot-strapping code will begin execution<br>
blindly from the first instruction, it will hit the firstretinstruction ofsomefunction<br>
and return to the boot sector code without ever having enteredmain. The problem<br>
is, that entering our kernel in the correct place is too dependant upon the ordering of<br>
elemtents (e.g. functions) in our kernel’s source code and upon the whims of the compiler<br>
and linker, so we need to make this more robust.<br>
A trick that many operating systems use to enter the kernel correctly is to write a<br>
very simple assembly routine that is always attached to the start of the kernel machine<br>
code, and whose sole purpose is to call the entry function of the kernel. The reason<br>
assembly is used is because we know exactly how it will be translated in machine code,<br>
and so we can make sure that the first instruction will eventually result in the kernel’s<br>
entry function being reached.<br>
This is a good example of how the linker works, since we haven’t really exploited<br>
this important tool yet. The linker takes object files as inputs, then joins them together,<br>
but resolves any labels to their correct addresses. For example, if one object file has a<br>
piece of code that has a call to a function,somefunction, defined in another object<br>
file, then after the object file’s code has been physically linked together into one file,<br>
the label :code:’somefunction’ will be resolved to the offset of wherever that particular<br>
routine ended up in the combined code.<br>
Figure XXX shows a simple assembly routine for entering the kernel.</p>
<pre><code>; Ensures that we jump straight into the kernel ’s entry function.
[bits 32] ; We’re in protected mode by now , so use 32-bit instructions.
[extern main] ; Declate that we will be referencing the external symbol ’main ’,
; so the linker can substitute the final address
</code></pre>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 54</p>
<pre><code>call main ; invoke main() in our C kernel
jmp $ ; Hang forever when we return from the kernel
</code></pre>
<p>You can see from the linecall mainthat the code simply calls a function that goes<br>
by the name ofmain. Butmaindoes not exist as a label within this code, since it is<br>
expected to exist within one of the other object files, such that it will be resolved to<br>
the correct address at link time; this expectance is expressed by the directive[extern<br>
main], at the top of the file, and the linker will fail if it doesn’t find such a label.<br>
Previously we have compiled assembly into a raw binary format, because we wanted<br>
to run it as boot sector code on the CPU, but for this piece of code cannot stand alone,<br>
without having that label resolved, so we must compile it as follows as an object file,<br>
therefore preserving meta information about the labels it must resolve:</p>
<p>$nasm kernelentry.asm -f elf -o kernelentry.o<br>
The option-f elftells the assembler to output an object file of the particular<br>
format Executable and Linking Format (ELF), which is the default format output by<br>
out C compiler.<br>
Now, rather that simple linking thekernel.ofile with itself to createkernel.bin,<br>
we can link it withkernelentry.o, as follows:</p>
<p>$ld -o kernel.bin -Ttext 0x1000 kernelentry.o kernel.o --oformat binary<br>
The linker respects the order of the files we gave to it on the command line, such<br>
that the previous command will ensure ourkernelentry.owill precede the code in<br>
kernel.o.<br>
As before, we can reconstruct our kernel image file with the following command:<br>
cat bootsect.bin kernel.bin &gt; os-image<br>
Now we can test this in Bochs, but with more reassurance that our boot-block will<br>
find its way into the correct entry point of our kernel.</p>
<h3 id="automating-builds-with-make">5.3 Automating Builds with Make</h3>
<p>By now you should be fed up of having to re-type lots of commands, every time you<br>
change a piece of code, to get some feedback on a correction or a new idea you tried.<br>
Again, programmers have been here before, and have developed a multitude of tools<br>
for automating the build process of software. Here we will considermake, which is the<br>
predecessor of many of these other build tools, and which is used for building, amongst<br>
other operating systems and applications, Linux and Minix. The basic principle ofmake<br>
is that we specify in a configuration file (usually calledMakefile) how to convert one<br>
file into another, such that the generation of one file may be describe to depend on the<br>
existence of one or more other file. For example, we could write the following rule in a<br>
Makefile, that would tellmakeexactly how to compile a C file into an object file:</p>
<pre><code>kernel.o : kernel.c
gcc -ffreestanding -c kernel.c -o kernel.o
The beauty of this is that, in the same directory as the Makefile, we can now type:
</code></pre>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 55</p>
<p>$make kernel.o<br>
which will re-compile our C source file only ifkernel.odoes not exist or has an<br>
older file modification time thankernel.c. But it is only when we add serveral inter-<br>
dependant rules that we see howmakecan really help us to save time and unecessary<br>
command executions.</p>
<pre><code># Build the kernel binary
kernel.bin: kernel_entry.o kernel.o
ld -o kernel.bin -Ttext 0x1000 kernel_entry.o kernel.o --oformat binary
</code></pre>
<pre><code># Build the kernel object file
kernel.o : kernel.c
gcc -ffreestanding -c kernel.c -o kernel.o
</code></pre>
<pre><code># Build the kernel entry object file.
kernel_entry.o : kernel_entry.asm
nasm kernel_entry.asm -f elf -o kernel_entry.o
</code></pre>
<p>If we run make kernel.bin with the Makefile in Figure XXX,makewill know<br>
that, before it can run the command to generatekernel.bin, it must build its two<br>
dependencies,kernel.oandkernelentry.o, from their source files,kernel.cand<br>
kernelentry.asm, yeilding the following output of the commands it ran:</p>
<p>nasm kernelentry.asm -f elf -o kernelentry.o<br>
gcc -ffreestanding -c kernel.c -o kernel.o<br>
ld -o kernel.bin -Ttext 0x1000 kernelentry.o kernel.o --oformat binary<br>
Then, if we runmakeagain, we will see that make reports that the build target<br>
kernel.binis up to date. However, if we modify, say,kernel.c, save it, then runmake<br>
kernel.bin, we will see that only the necessary commands are run bymake, as follows:</p>
<p>gcc -ffreestanding -c kernel.c -o kernel.o<br>
ld -o kernel.bin -Ttext 0x1000 kernelentry.o kernel.o --oformat binary<br>
To reduce repetition in, and therefore improve ease of maintenance of, our Makefile,<br>
we can use the special makefile variables<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">&lt;,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.3em; vertical-align: -0.19444em;"></span><span class="mpunct">,</span></span></span></span></span>@, and$^as in Figure XXX.</p>
<pre><code># $^ is substituted with all of the target ’s dependancy files
kernel.bin: kernel_entry.o kernel.o
ld -o kernel.bin -Ttext 0x1000 $^ --oformat binary
</code></pre>
<pre><code># $&lt; is the first dependancy and $@ is the target file
kernel.o : kernel.c
gcc -ffreestanding -c $&lt; -o $@
</code></pre>
<pre><code># Same as the above rule.
kernel_entry.o : kernel_entry.asm
nasm $&lt; -f elf -o $@
</code></pre>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 56</p>
<p>It is often useful to specify targets that are not actually real targets, in that they do<br>
not generate files. A common use of such phoney targets is to make acleantarget, so<br>
that when we runmake clean, all of the generated files are deleted from the directory,<br>
leaving only the source files, as in Figure XXX.</p>
<pre><code>clean:
rm *.bin *.o
</code></pre>
<p>Cleaning your directory in this way is useful if you’d like to distribute only the<br>
source files to a friend, put the directory under version control, or if you’d like to test<br>
that modifications of your makefile will correctly build all targets from scratch.<br>
Ifmakeis run without a target, the first target in the main file is taken to be the<br>
default, so you often see a phoney target such asallat the top of Makefile as in Figure<br>
XXX.</p>
<pre><code># Default make target.
all: kernel.bin
</code></pre>
<pre><code># $^ is substituted with all of the target ’s dependancy files
kernel.bin: kernel_entry.o kernel.o
ld -o kernel.bin -Ttext 0x1000 $^ --oformat binary
</code></pre>
<pre><code># $&lt; is the first dependancy and $@ is the target file
kernel.o : kernel.c
gcc -ffreestanding -c $&lt; -o $@
</code></pre>
<pre><code># Same as the above rule.
kernel_entry.o : kernel_entry.asm
nasm $&lt; -f elf -o $@
</code></pre>
<p>Note that, by givingkernel.binas a dependency to thealltarget, we ensure that<br>
kernel.binand all of its dependencies are built for the default target.<br>
We can now put all of the commands for building our kernel and the loadable kernel<br>
image into a useful makefile (see Figure XXX), that will allow us to test changes or<br>
corrections to our code in Bochs simply by typingmake run.</p>
<pre><code>all: os-image
</code></pre>
<pre><code># Run bochs to simulate booting of our code.
run: all
bochs
</code></pre>
<pre><code># This is the actual disk image that the computer loads ,
# which is the combination of our compiled bootsector and kernel
os-image: boot_sect.bin kernel.bin
cat $^ &gt; os -image
</code></pre>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 57</p>
<pre><code># This builds the binary of our kernel from two object files:
# - the kernel_entry , which jumps to main() in our kernel
# - the compiled C kernel
kernel.bin: kernel_entry.o kernel.o
ld -o kernel.bin -Ttext 0x1000 $^ --oformat binary
</code></pre>
<pre><code># Build our kernel object file.
kernel.o : kernel.c
gcc -ffreestanding -c $&lt; -o $@
</code></pre>
<pre><code># Build our kernel entry object file.
kernel_entry.o : kernel_entry.asm
nasm $&lt; -f elf -o $@
</code></pre>
<pre><code># Assemble the boot sector to raw machine code
# The -I options tells nasm where to find our useful assembly
# routines that we include in boot_sect.asm
boot_sect.bin : boot_sect.asm
nasm $&lt; -f bin -I ’../../16 bit/’ -o $@
</code></pre>
<pre><code># Clear away all generated files.
clean:
rm -fr *.bin *.dis *.o os-image *.map
</code></pre>
<pre><code># Disassemble our kernel - might be useful for debugging.
kernel.dis : kernel.bin
ndisasm -b 32 $&lt; &gt; $@
</code></pre>
<h4 id="organising-our-operating-system’s-code-base">5.3.1 Organising Our Operating System’s Code Base</h4>
<p>We have now arrived at a very simple C kernel, that prints out an ’X’ in the corner of<br>
the screen. The very fact that the kernel was compiled into 32-bit instructions and has<br>
successfully been executed by the CPU means that we have come far; but it is now time<br>
to prepare ourselves for the work ahead. We need to establish a suitable structure for<br>
our code, accompanied by a makefile that will allow us easily to add new source files<br>
with new features to our operating system, and to check those additions incrementally<br>
with an emulator such as Bochs.<br>
Similarly to kernels such as Linux and Minix, we can organise our code base into the<br>
following folders:</p>
<ul>
<li>boot: anything related to booting and the boot sector can go in here, such as<br>
bootsect.asmand our boot sector assembly routines (e.g. printstring.asm,<br>
gdt.asm,switchtopm.asm, etc.).</li>
<li>kernel: the kernel’s main file,kernel.c, and other kernel related code that is<br>
not device driver specific will go in here.</li>
<li>drivers: any hardware specific driver code will go in here.<br>
Now, within our makefile, rather than having to specify every single object file that<br>
we would like to build (e.g.kernel/kernel.o,drivers/screen.o,drivers/keyboard.o,<br>
etc.), we can use a specialwildcarddeclaration as follows:</li>
</ul>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 58</p>
<pre><code># Automatically expand to a list of existing files that
# match the patterns
C_SOURCES = $(wildcard kernel /*.c drivers /*.c)
</code></pre>
<p>Then we can convert the source filenames into object filenames using anothermake<br>
declaration, as follows:</p>
<pre><code># Create a list of object files to build , simple by replacing
# the ’.c’ extension of filenames in C_SOURCES with ’.o’
OBJ = ${C_SOURCES :.c=.o}
</code></pre>
<p>Now we can link the kernel object files together, to build the kernel binary, as follows:</p>
<pre><code># Link kernel object files into one binary , making sure the
# entry code is right at the start of the binary.
kernel.bin: kernel/kernel_entry.o ${OBJ}
ld -o $@ -Ttext 0x1000 $^ --oformat binary
</code></pre>
<p>A feature ofmakethat will go hand-in-hand with our dynamic inclusion of object files is<br>
pattern rules, which tellmakehow to build one file type from another based on simple<br>
pattern machine of the filename, as follows:</p>
<pre><code># Generic rule for building ’somefile.o’ from ’somefile.c’
%.o : %.c
gcc -ffreestanding -c $&lt; -o $@
</code></pre>
<p>The alternative to this would be much repetion, as follows:</p>
<pre><code>kernel/kernel.o : kernel/kernel.c
gcc -ffreestanding -c $&lt; -o $@
</code></pre>
<pre><code>drivers/screen.o : drivers/screen.c
gcc -ffreestanding -c $&lt; -o $@
</code></pre>
<pre><code>drivers/keyboard.o : drivers/keyboard.c
gcc -ffreestanding -c $&lt; -o $@
</code></pre>
<pre><code>...
</code></pre>
<p>Great, now that we understandmakesufficiently, we can progress to develop our kernel,<br>
without having to re-type lots of commands, over and over, to check if something is<br>
working correctly. Figure XXX shows a complete makefile that will be suitable for<br>
progressing with our kernel.</p>
<pre><code># Automatically generate lists of sources using wildcards.
C_SOURCES = $(wildcard kernel /*.c drivers /*.c)
HEADERS = $(wildcard kernel /*.h drivers /*.h)
</code></pre>
<pre><code># TODO: Make sources dep on all header files.
</code></pre>
<pre><code># Convert the *.c filenames to *.o to give a list of object files to build
OBJ = ${C_SOURCES :.c=.o}
</code></pre>
<pre><code># Defaul build target
all: os-image
</code></pre>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 59</p>
<pre><code># Run bochs to simulate booting of our code.
run: all
bochs
</code></pre>
<pre><code># This is the actual disk image that the computer loads
# which is the combination of our compiled bootsector and kernel
os-image: boot/boot_sect.bin kernel.bin
cat $^ &gt; os -image
</code></pre>
<pre><code># This builds the binary of our kernel from two object files:
# - the kernel_entry , which jumps to main() in our kernel
# - the compiled C kernel
kernel.bin: kernel/kernel_entry.o ${OBJ}
ld -o $@ -Ttext 0x1000 $^ --oformat binary
</code></pre>
<pre><code># Generic rule for compiling C code to an object file
# For simplicity , we C files depend on all header files.
%.o : %.c ${HEADERS}
gcc -ffreestanding -c $&lt; -o $@
</code></pre>
<pre><code># Assemble the kernel_entry.
%.o : %.asm
nasm $&lt; -f elf -o $@
</code></pre>
<pre><code>%.bin : %.asm
nasm $&lt; -f bin -I ’../../16 bit/’ -o $@
</code></pre>
<pre><code>clean:
rm -fr *.bin *.dis *.o os-image
rm -fr kernel /*.o boot /*.bin drivers /*.o
</code></pre>
<h3 id="c-primer">5.4 C Primer</h3>
<p>C has a few quirks that can unsettle a new programmer of the language.</p>
<h4 id="the-pre-processor-and-directives">5.4.1 The Pre-processor and Directives</h4>
<p>Before a C file is compiled into an object file, a pre-processor scans it for pre-processor<br>
directives and variables, and then usually substitutes them with code, such as macros<br>
and values of constants, or with nothing at all. The pre-processor is not essential for<br>
compiling C code, but serves rather to offer some convenience that makes the code more<br>
managable.</p>
<pre><code>#define PI 3.141592
...
float radius = 3.0;
float circumference = 2 * radius * PI;
...
</code></pre>
<p>The pre-processor would output the following code, ready for compilation:</p>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 60</p>
<pre><code>float radius = 3.0;
float circumference = 2 * radius * 3.141592;
</code></pre>
<p>The pre-processor is also useful for outputing conditional code, but not conditional in<br>
the sense that a decision is made at run-time, like with anifstatement, rather in the<br>
sense of compile-time. For example, consider the following use of pre-processor directives<br>
for the inclusion or exclusion of debugging code:</p>
<pre><code>#ifdef DEBUG
print("Some debug message\n");
#endif
</code></pre>
<p>Now, if the pre-processor variableDEBUGhas been defined, such debugging code will be<br>
included; otherwise, not. A variable may be defined on the command line when compiling<br>
the C file as follows:</p>
<p>$gcc -DDEBUG -c somefile.c -o somefile.o<br>
Such command line variable declarations are often used for compile-time configu-<br>
ration of applications, and especially operating systems, which may include or exclude<br>
whole sections of code, perhaps to reduce the memory footprint of the kernel on a small<br>
embedded device.</p>
<h4 id="function-declarations-and-header-files">5.4.2 Function Declarations and Header Files</h4>
<p>When the compiler encouters a call to a function, that may or may not be defined in the<br>
file being compiled, it may make incorrect assumptions and produce incorrect machine<br>
code instructions if it has not yet encountered a description of the functions return type<br>
and arguments. Recall from Section XXX that the compiler must prepare the stack for<br>
variables that it passes to a function, but if the stack is not what the function expects,<br>
then the stack may become corrupted. For this reason, it is important that at least a<br>
declaration of the function’s interface, if not the entire function definition, is given before<br>
it is used. This declaration is known as a function’sprototype.</p>
<pre><code>int add(int a, int b) {
return a + b;
}
</code></pre>
<pre><code>void main() {
// This is okay , because our compiler has seen the full
// definition of add.
int result = add(5, 3);
</code></pre>
<pre><code>// This is not okay , since compiler does not know the return
// type or anything about the arguments.
result = divide (34.3, 12.76);
</code></pre>
<pre><code>// This is not okay , because our compiler knows nothing about
</code></pre>
<p>CHAPTER 5. WRITING, BUILDING, AND LOADING YOUR</p>
<p>KERNEL 61</p>
<pre><code>// this function ’s interface.
int output = external_function (5, "Hello", 4.5);
}
</code></pre>
<pre><code>float divide(float a, float b) {
return a / b;
}
</code></pre>
<pre><code>This can be fixed as follows:
</code></pre>
<pre><code>// These function prototypes inform the compiler about
// the function interfaces.
float divide(float a, float b); // &lt;-- note the semi -colon
int external_function(int a, char* message , float b);
</code></pre>
<pre><code>int add(int a, int b) {
return a + b;
}
</code></pre>
<pre><code>void main() {
// This is okay , because our compiler has seen the full
// definition of add.
int result = add(5, 3);
</code></pre>
<pre><code>// This is okay now: compiler knows the interface.
result = divide (34.3, 12.76);
</code></pre>
<pre><code>// This is okay now: compiler knows the interface.
int output = external_function (5, "Hello", 4.5);
}
</code></pre>
<pre><code>float divide(float a, float b) {
return a / b;
}
</code></pre>
<p>Now, since some functions will be called from code compiled into other object files,<br>
they will also need to declare identical prototypes of those functions, which would lead to<br>
a lot of duplicated prototype declarations, which is difficult to maintain. For this reason,<br>
many C programs use the#includepre-processor directive to insert common code that<br>
contains the required prototypes prior to compilation. This common code is known as a<br>
header file, which we can think of as the interface to the compiled object file, and which<br>
is used as follows.<br>
Sometimes, one header file may include another, so it is important not to re-define<br>
the same code…</p>
<ul>
<li>Casting types</li>
</ul>
<h1 id="chapter-6">Chapter 6</h1>
<h1 id="developing-essential-device">Developing Essential Device</h1>
<h1 id="drivers-and-a-filesystem">Drivers and a Filesystem</h1>
<h5 id="intro-part.">INTRO PART.</h5>
<h3 id="hardware-inputoutput">6.1 Hardware Input/Output</h3>
<p>By writing to the screen we have actually already encountered a friendlier form of hard-<br>
ware I/O, known as memory-mapped I/O, whereby data written directly to a certain<br>
address range in main memory is written to the device’s internal memory buffer, but<br>
now it is time to understand more about this interaction between CPU and hardware.<br>
Let’s take the now-popular TFT monitor as an example. The screen’s surface is<br>
divided up into a matrix of backlit cells. By containing a layer of liquid crystals sand-<br>
wiched between polarised film, the amount of light passing through each cell can be<br>
varied by the application of an electric field, since liquid crystals have the property that,<br>
when subjected to an electrical field, their orientation may be altered in a consistent<br>
manner; as the orientation of the crystals changes, they alter the light wave’s direction<br>
of vibration, such that some of the light will be blocked by the polarised film at the<br>
screen’s surface. For a colour display, each cell is further divided into three areas that<br>
are overlaid with filters for red, blue, and green [?].<br>
So it is the hardware’s job to ensure that the appropriate cells, or sub-cell colour<br>
areas, get subjected to appropriate electrical field to reconstruct the desired image on the<br>
screen. This side of hardware is best left to specialist electronic engineers, but there will<br>
be acontrollerchip, ideally with well defined functionality that is described in the chip’s<br>
datasheet, on the device or motherboard with which the CPU can interact to direct<br>
the hardware. In reality, for reasons of backward compatibility, TFT monitors usually<br>
emulate older CRT monitors, and so can be driven by the motherboard’s standard VGA<br>
controller, which generates a complex analog signal that directs an electron beam to scan<br>
across the phosphor-coated screen, and since there isn’t really a CRT beam to direct,<br>
the TFT monitor cleverly interprets this signal as a digital image.</p>
<p>62</p>
<p>CHAPTER 6. DEVELOPING ESSENTIAL DEVICE DRIVERS AND A</p>
<p>FILESYSTEM 63</p>
<p>Internally, controller chips usually have several registers that can be read, written or<br>
both by the CPU, and it is the state of these registers that tell the controller what to<br>
do (e.g. what pins to set high or low to drive the hardware, or what internal function to<br>
perform). As an example, from the datasheet of Intel’s widely used82077AAsingle-chip<br>
floppy disk controller [?], we see there is a pin (pin 57, labelledME0) that drives the motor<br>
of the first floppy disk device (since a single controller can drive several such devices):<br>
when the pin is on, the motor spins; when off, the motor does not spin. The state of<br>
this particular pin is directly linked to a particular bit of the controller’s internal register<br>
named the Digital Output Register (DOR). The state of that register can then be set by<br>
setting a value, with the appropriate bit set (bit 4, in this case), across the chip’s data<br>
pins, labelledDB0–DB7, and using the chip’s register selection pins,A0–A2, to select<br>
theDORregister by its internal address0x2.</p>
<h4 id="io-buses">6.1.1 I/O Buses</h4>
<p>Although historically the CPU would talk directly to device controllers, with ever in-<br>
creasing CPU speeds, that would require the CPU artificially to slow down to the same<br>
speed as the slowest device, so it is more practical for the CPU to issue I/O instructions<br>
directly to the controller chip of a high-speed, top-levelbus. The bus controller is then<br>
responsible for relaying, at a compatible rate, the instructions to a particular device’s<br>
controller. Then to avoid the top-level bus having to slow down for slower devices, the<br>
controller of a another bus technology may be added as a device, such that we arrive at<br>
the hierarchy of buses found in modern computers [?].</p>
<h4 id="io-programming">6.1.2 I/O Programming</h4>
<p>So the question is, how do we read and write the registers of our device controllers (i.e.<br>
tell our devices what to do) programatically? In Intel architecture systems the registers<br>
of device controllers are mapped into an I/O address space, that is seperate from the main<br>
memory address space, then varients of the I/O instructionsinandoutare used to read<br>
and write data to the I/O addresses that are mapped to specific controller registers. For<br>
example, the floppy disk controller descibed earlier usually has itsDORregister mapped to<br>
I/O address0x3F2, so we could switch on the motor of the first drive with the following<br>
instructions:</p>
<pre><code>mov dx, 0x3f2 ; Must use DX to store port address
in al , dx ; Read contents of port (i.e. DOR) to AL
or al , 00001000b ; Switch on the motor bit
out dx, al ; Update DOR of the device.
</code></pre>
<p>In older systems, such as the Industry Standard Architecture (ISA) bus, the port ad-<br>
dresses would be statically assigned to the devices, but with modern plug-and-play buses,<br>
such as Peripheral Component Interconnect (PCI), BIOS can dynamically allocate I/O<br>
address to most devices before booting the operating system. Such dynamic allocation<br>
requires devices to communicate configuration information over the bus to describe the<br>
hardware such as: how many I/O ports are required to be reserved for the registers; how<br>
much memory-mapped space is required; and a unique ID of the hardware type, to allow<br>
appropriate drivers to be found later by the operating system [?].</p>
<p>CHAPTER 6. DEVELOPING ESSENTIAL DEVICE DRIVERS AND A</p>
<p>FILESYSTEM 64</p>
<p>A problem with port I/O is that we cannot express these low-level instructions in C<br>
language, so we have to learn a little bit aboutinlineassembly: most compilers allow you<br>
to inject snippets of assembly code into the body of a function, with gcc implementing<br>
this as follows:</p>
<pre><code>unsigned char port_byte_in(unsigned short port) {
// A handy C wrapper function that reads a byte from the specified port
// "=a" (result) means: put AL register in variable RESULT when finished
// "d" (port) means: load EDX with port
unsigned char result;
__asm__("in %%dx, %%al" : "=a" (result) : "d" (port ));
return result;
}
</code></pre>
<p>Note that the actual assembly instruction,in %%dx, %%al, looks a little strange to<br>
us, since gcc adopts a different assembly syntax (known as GAS), where the target and<br>
destination operands are reversed with respect to the syntax of our more familiar nasm<br>
syntax; also,%is used to denote registers, and this requires an ugly%%, since%is an<br>
escape character of the C compiler, and so%%means: escape the escape character, so<br>
that it will appear literally in the string.<br>
Since these low-level port I/O functions will be used by most hardware drivers in<br>
our kernel, let’s collect them together into the filekernel/lowlevel.c, which we can<br>
define as in Figure XXX.</p>
<pre><code>unsigned char port_byte_in(unsigned short port) {
// A handy C wrapper function that reads a byte from the specified port
// "=a" (result) means: put AL register in variable RESULT when finished
// "d" (port) means: load EDX with port
unsigned char result;
__asm__("in %%dx, %%al" : "=a" (result) : "d" (port ));
return result;
}
</code></pre>
<pre><code>void port_byte_out(unsigned short port , unsigned char data) {
// "a" (data) means: load EAX with data
// "d" (port) means: load EDX with port
__asm__("out %%al, %%dx" : :"a" (data), "d" (port ));
}
</code></pre>
<pre><code>unsigned short port_word_in(unsigned short port) {
unsigned short result;
__asm__("in %%dx, %%ax" : "=a" (result) : "d" (port ));
return result;
}
</code></pre>
<pre><code>void port_word_out(unsigned short port , unsigned short data) {
__asm__("out %%ax, %%dx" : :"a" (data), "d" (port ));
}
</code></pre>
<p>CHAPTER 6. DEVELOPING ESSENTIAL DEVICE DRIVERS AND A</p>
<p>FILESYSTEM 65</p>
<h4 id="direct-memory-access">6.1.3 Direct Memory Access</h4>
<p>Since port I/O involves reading or writing individual bytes or words, the transfer of large<br>
amounts of data between a disk device and memory could potentially take up a great<br>
deal of better-spent CPU time. This issue has necessitated a means for the CPU to pass<br>
over this tedious task to someone else, a direct memory access (DMA) controller [?].<br>
A good analogy of DMA is that of an architect wanting to move a wall from one<br>
place to another. The architect knows eactly what is to be done but has other important<br>
things to consider other than shifting each brick, and so instructs a builder to move the<br>
bricks, one by one, and to alert (i.e. interrupt) him when either the wall is finished or if<br>
there was some error that is stopping the wall from being finished.</p>
<h3 id="screen-driver">6.2 Screen Driver</h3>
<p>So far, our kernel is capable of printing an ’X’ in the corner of the screen, which, whilst<br>
is sufficient to let us know our kernel has been successfully loaded and executed, doesn’t<br>
tell us much about what is happening on the computer.<br>
We know that we can have characters displayed on the screen by writing them<br>
somewhere within the display buffer at address0xb8000, but we don’t want to keep<br>
having to worry about that sort of low-level manipulation throughout our kernel. It<br>
would be much nicer if we could create an abstraction of the screen that would allow us<br>
to writeprint(‘‘Hello’’), and perhapsclearscreen(); and if it could scroll when<br>
we printed beyond the last display line, that would be icing on the cake. Not only would<br>
this sort of abstraction make it easier to display information within other code of our<br>
kernel, but it would allow us to easily substitute one display driver for another at a later<br>
date, perhaps if a certain computer could not support the colour VGA text mode that<br>
we currently assume.</p>
<h4 id="understanding-the-display-device">6.2.1 Understanding the Display Device</h4>
<p>Compared with some of the other hardware that we will soon look at, the display device<br>
is fairly straightforward, since, as a memory-mapped device, we can get by without<br>
understanding anything about control messages and hardware I/O. However, a useful<br>
device of the screen that requires I/O control (i.e. via I/O ports) to manipulate is the<br>
cursor, that flashes to mark the next position that a character will be written to on the<br>
screen. This is useful for a user, since it can draw their attention to a prompt to enter<br>
some text, but we will also use it as an internal marker, whether the cursor is visible or<br>
not, so that a programmer does not always have to specify the coordinates of where on<br>
the screen a string is to be displayed, for example: if we writeprint(‘‘hello’’), each<br>
character will be written to.</p>
<h4 id="basic-screen-driver-implementation">6.2.2 Basic Screen Driver Implementation</h4>
<p>Although we could write all of this code inkernel.c, that contains the kernel’s entry<br>
function,main(), it is good to organise such functionality-specific code into it’s own file,<br>
which can be compiled and linked to our kernel code, ulimately with the same effect as<br>
putting it all into one file. Let’s create a new driver implementation file,screen.c, and</p>
<p>CHAPTER 6. DEVELOPING ESSENTIAL DEVICE DRIVERS AND A</p>
<p>FILESYSTEM 66</p>
<p>a driver interface file,screen.h, in ourdriversfolder. Due to our use ofwildcardfile<br>
inclusion in our makefile,screen.cwill (as will any other C files placed in that folder)<br>
be automatically compiled and linked to our kernel.<br>
Firstly, let’s define the following constants inscreen.h, to make our code more<br>
readible:</p>
<pre><code>#define VIDEO_ADDRESS 0xb8000
#define MAX_ROWS 25
#define MAX_COLS 80
// Attribute byte for our default colour scheme.
#define WHITE_ON_BLACK 0x0f
</code></pre>
<pre><code>// Screen device I/O ports
#define REG_SCREEN_CTRL 0x3D4
#define REG_SCREEN_DATA 0x3D5
</code></pre>
<p>Then, let’s consider how we would write a function,printchar(…), that dis-<br>
plays a single character at a specific column and row of the screen. We will use this<br>
function internally (i.e. privately), within our driver, such that our driver’s public in-<br>
terface functions (i.e. the functions that we would like external code to use) will build<br>
upon it. We now know that video memory is simply a specific range of memory ad-<br>
dresses, where each character cell is represented by two bytes, the first byte is the ASCII<br>
code of the character, and the second byte is an attribute byte, that allows us to set<br>
a colourscheme of the character cell. Figure XXX shows how we could define such a<br>
function, by making use of some other functions that we will define: getcursor(),<br>
setcursor(),getscreenoffset(), andhandlescrolling().</p>
<pre><code>/* Print a char on the screen at col , row , or at cursor position */
void print_char(char character , int col , int row , char attribute_byte) {
/* Create a byte (char) pointer to the start of video memory */
unsigned char *vidmem = (unsigned char *) VIDEO_ADDRESS;
</code></pre>
<pre><code>/* If attribute byte is zero , assume the default style. */
if (! attribute_byte) {
attribute_byte = WHITE_ON_BLACK;
}
</code></pre>
<pre><code>/* Get the video memory offset for the screen location */
int offset;
/* If col and row are non -negative , use them for offset. */
if (col &gt;= 0 &amp;&amp; row &gt;= 0) {
offset = get_screen_offset(col , row);
/* Otherwise , use the current cursor position. */
} else {
offset = get_cursor ();
}
</code></pre>
<pre><code>// If we see a newline character , set offset to the end of
// current row , so it will be advanced to the first col
// of the next row.
if (character == ’\n’) {
</code></pre>
<p>CHAPTER 6. DEVELOPING ESSENTIAL DEVICE DRIVERS AND A</p>
<p>FILESYSTEM 67</p>
<pre><code>int rows = offset / (2* MAX_COLS );
offset = get_screen_offset (79, rows);
// Otherwise , write the character and its attribute byte to
// video memory at our calculated offset.
} else {
vidmem[offset] = character;
vidmem[offset +1] = attribute_byte;
}
</code></pre>
<pre><code>// Update the offset to the next character cell , which is
// two bytes ahead of the current cell.
offset += 2;
// Make scrolling adjustment , for when we reach the bottom
// of the screen.
offset = handle_scrolling(offset );
// Update the cursor position on the screen device.
set_cursor(offset );
}
</code></pre>
<p>Let’s tackle the easiest of these functions first: getscreenoffset. This function<br>
will map row and column coordinates to the memory offset of a particular display char-<br>
acter cell from the start of video memory. The mapping is straightforward, but we must<br>
remember that each cell holds two bytes. For example, if I want to set a character at<br>
row 3, column 4 of the display, then the character cell of that will be at a (decimal)<br>
offset of 488 ((3 * 80 (i.e. the the row width) + 4) * 2 = 488) from the start<br>
of video memory. So ourgetscreenoffsetfunction will look something like that in<br>
Figure XXX.</p>
<pre><code>// This is similar to get_cursor , only now we write
// bytes to those internal device registers.
port_byte_out(REG_SCREEN_CTRL , 14);
port_byte_out(REG_SCREEN_DATA , (unsigned char)( offset &gt;&gt; 8));
port_byte_out(REG_SCREEN_CTRL , 15);
</code></pre>
<p>Now let’s look at the cursor control functions,getcursor()andsetcursor(),<br>
which will manipulate the display controller’s registers via a set of I/O ports. Using the<br>
specfic video devices I/O ports to read and write its internal cursor-related registers, the<br>
implementation of these functions will look something like that in Figure XXX.</p>
<pre><code>cursor_offset -= 2* MAX_COLS;
</code></pre>
<pre><code>// Return the updated cursor position.
return cursor_offset;
}
</code></pre>
<pre><code>int get_cursor () {
// The device uses its control register as an index
// to select its internal registers , of which we are
// interested in:
</code></pre>
<p>CHAPTER 6. DEVELOPING ESSENTIAL DEVICE DRIVERS AND A</p>
<p>FILESYSTEM 68</p>
<pre><code>// reg 14: which is the high byte of the cursor ’s offset
// reg 15: which is the low byte of the cursor ’s offset
// Once the internal register has been selected , we may read or
// write a byte on the data register.
port_byte_out(REG_SCREEN_CTRL , 14);
int offset = port_byte_in(REG_SCREEN_DATA) &lt;&lt; 8;
port_byte_out(REG_SCREEN_CTRL , 15);
offset += port_byte_in(REG_SCREEN_DATA );
// Since the cursor offset reported by the VGA hardware is the
// number of characters , we multiply by two to convert it to
// a character cell offset.
return offset *2;
}
</code></pre>
<pre><code>void set_cursor(int offset) {
offset /= 2; // Convert from cell offset to char offset.
// This is similar to get_cursor , only now we write
// bytes to those internal device registers.
</code></pre>
<p>So now we have a function that will allow us to print a character at a specific<br>
location of the screen, and that function encapsulates all of the messy hardware specific<br>
stuff. Usually, we will not want to print each charater to the screen, but rather a whole<br>
string of characters, so let’s create a friendlier function,printat(…), that takes a<br>
pointer to the first character of a string (i.e. achar *) and prints each subsequent<br>
character, one after the other, from the given coordinates. If the coordinates(-1,-1)<br>
are passed to the function, then it will start printing from the current cursor location.<br>
Ourprintat(…)function will look something like that in Figure XXX.</p>
<pre><code>void print_at(char* message , int col , int row) {
// Update the cursor if col and row not negative.
if (col &gt;= 0 &amp;&amp; row &gt;= 0) {
set_cursor(get_screen_offset(col , row));
}
// Loop through each char of the message and print it.
int i = 0;
while(message[i] != 0) {
print_char(message[i++], col , row , WHITE_ON_BLACK );
}
}
</code></pre>
<p>And purely for convenience, to save us from having to typeprintat(‘‘hello’’,<br>
-1,-1), we can define a function,print, that takes only one argument as in Figure<br>
XXX.</p>
<pre><code>void print(char* message) {
print_at(message , -1, -1);
}
</code></pre>
<p>CHAPTER 6. DEVELOPING ESSENTIAL DEVICE DRIVERS AND A</p>
<p>FILESYSTEM 69</p>
<p>Another useful, but not too difficult function, isclearscreen(…), which will<br>
allow us to tidy up our screen by writing blank characters at every position. Figure<br>
XXX shows how we might implement such a function.</p>
<pre><code>void clear_screen () {
int row = 0;
int col = 0;
/* Loop through video memory and write blank characters. */
for (row=0; row &lt;MAX_ROWS; row++) {
for (col=0; col &lt;MAX_COLS; col++) {
print_char(’ ’, col , row , WHITE_ON_BLACK );
}
}
</code></pre>
<pre><code>// Move the cursor back to the top left.
set_cursor(get_screen_offset (0, 0));
}
</code></pre>
<h4 id="scrolling-the-screen">6.2.3 Scrolling the Screen</h4>
<p>If you expected the screen to scroll automatically when your cursor reached the bottom<br>
of the screen, then your brain must have lapsed back into higher-level computer land.<br>
This can be forgiven, because screen scrolling seems like such a natural thing that we<br>
simply take for granted; but working at this level, we have complete control over the<br>
hardware, and so must implement this feature ourselves.<br>
In order to make the screen appear to scroll when we reach the bottom, we must<br>
move each character cell upwards by one row, and then clear the last row, ready for<br>
writing the new row (i.e. the row that would otherwise have been written beyond the<br>
end of the screen). This means the the top row will be overwritten by the second row,<br>
and so the top row will be lost forever, which we will not concern ourselves with, since<br>
our aim is to allow the user to see the most recent log of activity on their computer.<br>
A nice way to implement scrolling is to call a function, which we will define as<br>
handlescrolling, immediately after incrementing the cursors position in ourprintchar.<br>
The the roll ofhandlescrolling, then, is to ensure that, whenever the cursor’s video<br>
memory offset is incremented beyond the last row of the screen, the rows are scrolled<br>
and the cursor is repositioned within the last visible row (i.e. the new row).<br>
Shifting a row equates to copying all of its bytes — two bytes for each of the 80<br>
character cells in a row — to the address of the previous row. This is a perfect op-<br>
portunity for adding a general purposememorycopyfunction to our operating system.<br>
Since we are likely to use such a function in other areas of our OS, let’s add it to the<br>
filekernel/util.c. Ourmemorycopyfunction will take addresses of the source and<br>
destination and the number of bytes to copy, then, with a loop, will copy each byte as<br>
in Figure XXX.</p>
<pre><code>/* Copy bytes from one place to another. */
void memory_copy(char* source , char* dest , int no_bytes) {
</code></pre>
<p>CHAPTER 6. DEVELOPING ESSENTIAL DEVICE DRIVERS AND A</p>
<p>FILESYSTEM 70</p>
<pre><code>int i;
for (i=0; i&lt;no_bytes; i++) {
*(dest + i) = *( source + i);
}
}
</code></pre>
<pre><code>Now we can usememorycopy, as in Figure XXX, to scroll our screen.
</code></pre>
<pre><code>/* Advance the text cursor , scrolling the video buffer if necessary. */
int handle_scrolling(int cursor_offset) {
</code></pre>
<pre><code>// If the cursor is within the screen , return it unmodified.
if (cursor_offset &lt; MAX_ROWS*MAX_COLS *2) {
return cursor_offset;
}
</code></pre>
<pre><code>/* Shuffle the rows back one. */
int i;
for (i=1; i&lt;MAX_ROWS; i++) {
memory_copy(get_screen_offset (0,i) + VIDEO_ADDRESS ,
get_screen_offset (0,i-1) + VIDEO_ADDRESS ,
MAX_COLS *2
);
}
</code></pre>
<pre><code>/* Blank the last line by setting all bytes to 0 */
char* last_line = get_screen_offset (0,MAX_ROWS -1) + VIDEO_ADDRESS;
for (i=0; i &lt; MAX_COLS *2; i++) {
last_line[i] = 0;
}
</code></pre>
<pre><code>// Move the offset back one row , such that it is now on the last
// row , rather than off the edge of the screen.
cursor_offset -= 2* MAX_COLS;
// Return the updated cursor position.
return cursor_offset;
}
</code></pre>
<h3 id="handling-interrupts">6.3 Handling Interrupts</h3>
<h3 id="keyboard-driver">6.4 Keyboard Driver</h3>
<h3 id="hard-disk-driver">6.5 Hard-disk Driver</h3>
<h3 id="file-system">6.6 File System</h3>
<h1 id="chapter-7">Chapter 7</h1>
<h1 id="implementing-processes">Implementing Processes</h1>
<h3 id="single-processing">7.1 Single Processing</h3>
<h3 id="multi-processing">7.2 Multi-processing</h3>
<p>71</p>
<h1 id="chapter-8">Chapter 8</h1>
<h1 id="summary-1">Summary</h1>
<p>72</p>
<h1 id="bibliography">Bibliography</h1>
<p>73</p>

    </div>
  </div>
</body>

</html>
